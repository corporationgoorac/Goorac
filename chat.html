<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#0A0A0A">

    <meta charset="UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <title>Goorac | Quantum Chat</title>

    <script src="config.js"></script>

    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-storage.js"></script>

    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Abril+Fatface&family=Bangers&family=Dancing+Script:wght@700&family=Fredoka:wght@600&family=Orbitron:wght@700&family=Playfair+Display:ital,wght@1,700&family=Righteous&display=swap" rel="stylesheet">

    <script type="module" src="components/presence.js"></script>
    <script src="components/emojiPicker.js" defer></script>
    <script src="components/imagePicker.js" defer></script>
    <script src="components/filePicker.js" defer></script>
    <script src="components/viewMedia.js" defer></script>

    <style>
        /* =========================================
           1. CORE VARIABLES & THEME DEFINITIONS
           ========================================= */
        :root { 
            /* Deep, immersive dark mode background */
            --bg: #000000;
            --bg-gradient: radial-gradient(circle at 50% 30%, #111111 0%, #000000 70%);
            
            /* Header transparency and blur */
            --header-bg: rgba(10, 10, 10, 0.90);
            --header-blur: blur(25px);

            /* Brand Colors - THEME: PROFESSIONAL DARK ORANGE GRADE */
            --accent: #FF6D00; /* Deep Professional Orange */
            --accent-dark: #E65100;
            --accent-dim: rgba(255, 109, 0, 0.2);
            --glass-border: rgba(255, 255, 255, 0.08);
            
            /* Borders & Separators */
            --border: #1c1c1c; 
            --border-light: rgba(255,255,255,0.1);
            
            /* Message Bubbles - SENT (Dark Orange Gradient) */
            --sent-bg: linear-gradient(135deg, #E65100 0%, #FF6D00 100%);
            --sent-text: #ffffff;
            --sent-shadow: 0 4px 15px rgba(230, 81, 0, 0.25);
            
            /* Message Bubbles - RECEIVED (Dark Grey) */
            --received-bg: #262626; 
            --received-text: #ffffff;
            --received-shadow: 0 2px 5px rgba(0,0,0,0.2);
            
            /* Typography */
            --text: #ffffff; 
            --text-secondary: #a1a1a1;
            --text-muted: #666666;
            
            /* Animation Effects */
            --shimmer: linear-gradient(90deg, #1a1a1a 0%, #2a2a2a 50%, #1a1a1a 100%);
            --ease-elastic: cubic-bezier(0.175, 0.885, 0.32, 1.275);
            --ease-smooth: cubic-bezier(0.33, 1, 0.68, 1);
            --ease-out-back: cubic-bezier(0.34, 1.56, 0.64, 1);
            --ease-spring: cubic-bezier(0.68, -0.55, 0.265, 1.55); /* New Physics */
        }

        /* =========================================
           2. RESET & BASE STYLES
           ========================================= */
        * { 
            box-sizing: border-box; 
            -webkit-tap-highlight-color: transparent; 
            margin: 0; 
            padding: 0; 
            -webkit-touch-callout: none; 
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden; /* Prevent body scroll, handle in chat-flow */
            background: var(--bg);
            background-image: var(--bg-gradient);
            position: fixed; /* Fix for iOS rubber-banding */
            left: 0; 
            top: 0;
            overscroll-behavior: none;
        }

        body { 
            -webkit-user-select: none; 
            user-select: none; 
            color: var(--text); 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; 
            font-size: 16px;
        }

        /* Strict Input Control */
        div, span, p, img, svg { -webkit-user-select: none; user-select: none; }
        
        input, textarea { 
            -webkit-user-select: text !important; 
            user-select: text !important; 
            outline: none; 
            font-family: inherit;
        }

        /* =========================================
           3. ANIMATION KEYFRAMES
           ========================================= */
        @keyframes shimmer { 
            0% { background-position: -400px 0; } 
            100% { background-position: 400px 0; } 
        }
        
        @keyframes flashMessage { 
            0% { background-color: rgba(255, 152, 0, 0.3); transform: scale(1.02); } 
            100% { background-color: transparent; transform: scale(1); } 
        }
        
        @keyframes fadeStatus { 
            0% { opacity: 0; transform: translateY(3px); } 
            100% { opacity: 1; transform: translateY(0); } 
        }
        
        @keyframes shake { 
            0%, 100% { transform: translateX(0); } 
            10%, 30%, 50%, 70%, 90% { transform: translateX(-3px); } 
            20%, 40%, 60%, 80% { transform: translateX(3px); } 
        }
        
        @keyframes pulseGreen { 
            0% { box-shadow: 0 0 0 0 rgba(0, 230, 118, 0.7); } 
            70% { box-shadow: 0 0 0 5px rgba(0, 230, 118, 0); } 
            100% { box-shadow: 0 0 0 0 rgba(0, 230, 118, 0); } 
        }
        
        @keyframes imgFadeIn { 
            from { opacity: 0; transform: scale(0.99); } 
            to { opacity: 1; transform: scale(1); } 
        }

        @keyframes slideUp {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes bounce { 
            0%, 100% { transform: translateY(0); } 
            50% { transform: translateY(-6px); } 
        }

        /* REACTION POP ANIMATION - PHYSICS IMPROVED */
        @keyframes popOut {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.5); opacity: 1; }
            70% { transform: scale(0.9); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        /* BADGE POP UPDATE - SMOOTHER */
        @keyframes badgeUpdate {
            0% { transform: scale(1); }
            40% { transform: scale(1.35); background: #444; }
            70% { transform: scale(0.95); }
            100% { transform: scale(1); background: #2a2a2a; }
        }

        /* LIVE FLOATING EMOJI */
        @keyframes floatUp {
            0% { transform: translateY(0) scale(0.5); opacity: 0; }
            10% { transform: translateY(-20px) scale(1.2); opacity: 1; }
            50% { transform: translateY(-80px) scale(1.1); opacity: 1; }
            100% { transform: translateY(-160px) scale(0.9); opacity: 0; }
        }

        .shake-anim { animation: shake 0.4s ease-in-out; border-color: #ff453a !important; }

        .loading-shimmer {
            background: var(--shimmer); 
            background-size: 800px 100%; 
            animation: shimmer 2s linear infinite;
        }

        /* INSTANT LOAD OVERRIDES */
        .instant-load .loading-shimmer { animation: none; background: transparent; }
        .instant-load .chat-media-img { animation: none; }
        .instant-load #chat-flow { opacity: 1 !important; transition: none !important; }

        /* =========================================
           4. LAYOUT STRUCTURE
           ========================================= */
        .app-container { 
            display: flex; 
            flex-direction: column; 
            height: 100vh; 
            height: 100dvh; 
            width: 100%; 
            position: absolute; 
            top: 0; left: 0; 
            overflow: hidden;
        }

        /* =========================================
           5. HEADER STYLES (Optimized for Mobile)
           ========================================= */
        header { 
            position: absolute; 
            top: 0; left: 0; right: 0;
            padding: 0 10px;
            padding-top: calc(env(safe-area-inset-top) + 6px);
            height: calc(60px + env(safe-area-inset-top));
            background: var(--header-bg); 
            border-bottom: 1px solid var(--border-light); 
            display: flex; 
            align-items: center; 
            gap: 2px; 
            z-index: 2000; 
            backdrop-filter: var(--header-blur);
            -webkit-backdrop-filter: var(--header-blur);
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .back-btn { 
            font-size: 24px; 
            color: var(--accent); 
            cursor: pointer; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            height: 44px; 
            width: 44px; 
            border-radius: 50%;
            transition: background 0.2s;
            margin-right: 0px;
        }
        .back-btn:active { background: rgba(255,255,255,0.1); }
        /* Professional Chevron Icon Sizing */
        .back-btn span { font-size: 32px; font-weight: 500; }

        .h-profile-group { 
            display: flex; 
            align-items: center; 
            gap: 10px; 
            cursor: pointer; 
            flex: 1; 
            overflow: hidden; 
            padding: 4px;
            border-radius: 12px;
            transition: background 0.2s;
            min-width: 0; /* Critical for truncation fix */
            margin-right: 4px;
        }
        .h-profile-group:active { background: rgba(255,255,255,0.05); }
        
        .pfp-container { 
            position: relative; 
            width: 38px; 
            height: 38px; 
            flex-shrink: 0; 
        }
        
        .h-pfp { 
            width: 100%; 
            height: 100%; 
            border-radius: 50%; 
            object-fit: cover; 
            background: #1a1a1a; 
            border: 1px solid rgba(255,255,255,0.15); 
            transition: opacity 0.3s ease; 
        }
        
        .online-dot { 
            position: absolute; 
            bottom: 0px; 
            right: 0px; 
            width: 12px; 
            height: 12px; 
            background: #32D74B; 
            border-radius: 50%; 
            border: 2px solid #000; 
            display: none; 
            box-shadow: 0 0 10px rgba(50, 215, 75, 0.5); 
            animation: pulseGreen 3s infinite; 
        }
        
        .h-info { 
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            gap: 1px; 
            min-width: 0; /* Ensures container shrinks */
            flex: 1; 
        }
    
        
        .h-name { 
            font-weight: 700; 
            font-size: 1.05rem; 
            color: #fff; 
            white-space: nowrap; 
            overflow: hidden; 
            text-overflow: ellipsis; 
            letter-spacing: 0.2px;
            flex: 1; /* Allow name to take available space */
        }
 
.h-name-wrapper {
    display: flex;
    align-items: center;
    gap: 4px; /* Distance between Name and Tick */
    width: fit-content; /* Keeps the tick attached to the name */
    max-width: 100%;
}

.v-badge { 
    width: 16px; 
    height: 16px; 
    display: none; /* Changed from block to none */
    flex-shrink: 0;
    position: relative; 
    top: -1.7px; /* Moves it up exactly 1 pixel */
}
        
        .h-username-sub { 
            font-size: 0.8rem; 
            color: var(--text-secondary); 
            font-weight: 500; 
            transition: opacity 0.3s ease, color 0.3s ease;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        

        .header-actions { 
            display: flex; 
            align-items: center; 
            gap: 4px; /* Professional Gap */
            margin-left: auto; 
            padding-right: 2px;
            flex-shrink: 0;
        }
        
        .header-icon { 
            width: 36px; 
            height: 36px; 
            cursor: pointer; 
            color: #ffffff; 
            opacity: 0.9; 
            transition: transform 0.2s, opacity 0.2s; 
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }
        .header-icon:active { opacity: 0.6; transform: scale(0.92); background: rgba(255,255,255,0.1); }
        .header-icon span { font-size: 24px; } 

        /* PULSE ICON STYLES */
        .pulse-icon { color: var(--accent); }
        .pulse-icon span { animation: breathe 2s infinite ease-in-out; }
        @keyframes breathe {
            0% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 0.8; }
        }

        /* --- PULSE INVITE BANNER --- */
        #pulse-invite-banner {
            position: absolute;
            top: calc(62px + env(safe-area-inset-top));
            left: 0; right: 0;
            background: linear-gradient(135deg, rgba(255, 109, 0, 0.15), rgba(0, 0, 0, 0.8));
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--accent);
            padding: 10px 16px;
            display: none; /* Hidden by default */
            align-items: center;
            justify-content: space-between;
            z-index: 1500;
            animation: slideDown 0.3s ease-out;
        }
        @keyframes slideDown { from { transform: translateY(-20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        
        .invite-content { display: flex; align-items: center; gap: 10px; font-size: 0.85rem; color: #fff; font-weight: 600; }
        .invite-pulse-icon { color: var(--accent); font-size: 20px; animation: pulseGreen 1.5s infinite; }
        
        .invite-actions { display: flex; gap: 10px; }
        .btn-join { 
            background: var(--accent); color: #000; border: none; padding: 6px 12px; 
            border-radius: 20px; font-weight: 700; font-size: 0.75rem; cursor: pointer; 
        }
        .btn-dismiss { 
            background: rgba(255,255,255,0.1); color: #ccc; border: none; padding: 6px 12px; 
            border-radius: 20px; font-size: 0.75rem; cursor: pointer; 
        }

        /* =========================================
           6. CHAT AREA (SCROLLABLE)
           ========================================= */
        #chat-flow { 
            flex: 1; 
            overflow-y: auto; 
            overflow-x: hidden; 
            padding: 0; 
            display: flex; 
            flex-direction: column; 
            -webkit-overflow-scrolling: touch;
            background: transparent; 
            overscroll-behavior-y: contain; 
            position: relative;
            
            /* KEY FIX FOR JUMPING: Anchor Scroll */
            overflow-anchor: auto;

            /* PADDING TOP to clear absolute header & potentially banner */
            padding-top: calc(75px + env(safe-area-inset-top)); 
            padding-bottom: 20px;
            
            /* Hide Scrollbar */
            -ms-overflow-style: none; 
            scrollbar-width: none;
            
            /* Initial State */
            opacity: 0; 
            transition: opacity 0.1s ease-in;
        }
        #chat-flow::-webkit-scrollbar { display: none; }
        
        #messages-container { 
            display: flex; 
            flex-direction: column; 
            padding: 0 12px; 
            width: 100%; 
            /* FIX 2: Added extra bottom padding so last msg timestamp isn't hidden */
            padding-bottom: 10px; /* MODIFIED: Removed the 50px artificial gap */
            /* Performance Optimization */
            will-change: transform;
            contain: content;
            touch-action: pan-y; 
        }

        /* =========================================
           7. TYPING INDICATOR
           ========================================= */
        .typing-row { 
            display: none; 
            align-items: flex-end; 
            margin-bottom: 12px; 
            padding-left: 12px; 
            width: 100%;
        }
        .typing-avatar { 
            width: 28px; height: 28px; 
            border-radius: 50%; 
            margin-right: 8px; 
            object-fit: cover; 
            background: #1a1a1a; 
            border: 1px solid rgba(255,255,255,0.1);
        }
        .typing-bubble { 
            background: var(--received-bg); 
            padding: 12px 16px; 
            border-radius: 18px; 
            border-bottom-left-radius: 4px; 
            display: flex; 
            gap: 4px; 
            align-items: center; 
            width: fit-content; 
            height: 38px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.05);
        }

        .typing-dot { 
            width: 6px; height: 6px; 
            background: #888; 
            border-radius: 50%; 
            animation: typingWave 1.4s ease-in-out infinite; 
        }
        .typing-dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-dot:nth-child(3) { animation-delay: 0.4s; }
        
        @keyframes typingWave { 
            0%, 100% { transform: translateY(0); opacity: 0.4; } 
            50% { transform: translateY(-4px); opacity: 1; } 
        }

        #scroll-trigger { text-align: center; padding: 20px; opacity: 0; pointer-events: none; order: -1; }
        
        /* DATE DIVIDER */
        .date-divider { 
            text-align: center; 
            margin: 24px 0 16px 0; 
            font-size: 0.7rem; 
            color: var(--text-secondary); 
            font-weight: 600; 
            text-transform: uppercase;
            letter-spacing: 0.8px; 
            align-self: center; 
            width: fit-content; 
            position: sticky; 
            top: 10px; 
            z-index: 5; 
            background: rgba(20, 20, 20, 0.7); 
            padding: 4px 12px; 
            border-radius: 12px; 
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.05);
        }

        /* FIX 3: TIME DIVIDER (Same Style) */
        .time-divider {
            text-align: center; 
            margin: 20px 0 12px 0; 
            font-size: 0.65rem; 
            color: #777; 
            font-weight: 500; 
            align-self: center; 
            width: 100%;
        }

        /* =========================================
           8. MESSAGE ROW & BUBBLES
           ========================================= */
        .msg-row { 
            display: flex; 
            width: 100%; 
            margin-bottom: 2px; 
            position: relative; 
            flex-direction: column; 
            overflow: visible; 
            transform: translateZ(0);
        }
        
        /* Spacing for groups */
        .msg-row.group-bottom, .msg-row.single { margin-bottom: 10px; }

        .msg-row.sent { align-items: flex-end; padding-right: 0px; }
        .msg-row.received { align-items: flex-start; }
        
        .received-inner-row { display: flex; align-items: flex-end; gap: 8px; max-width: 100%; position: relative; }
        
        .msg-avatar { 
            width: 28px; height: 28px; 
            border-radius: 50%; 
            object-fit: cover; 
            flex-shrink: 0; 
            margin-bottom: 4px; 
            background: #1a1a1a; 
            border: 1px solid rgba(255,255,255,0.1); 
            opacity: 0; 
        }
        .msg-avatar.visible { opacity: 1; }

        .msg-bubble-box { 
            position: relative; 
            max-width: 75vw; /* FIX: Use viewport width so both sent and received have the exact same max width ignoring avatar */
            display: flex; 
            flex-direction: column; 
            transition: transform 0.2s, padding-bottom 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94); /* Smooth expand */
        }
        .sent .msg-bubble-box { align-items: flex-end; }
        .received .msg-bubble-box { align-items: flex-start; }

        .bubble { 
            padding: 12px 16px; /* MODIFIED: Uniform professional padding */
            border-radius: 20px; 
            font-size: 1rem; 
            line-height: 1.4; 
            position: relative; 
            word-wrap: break-word; 
            z-index: 2; 
            transition: box-shadow 0.2s ease;
        }

        /* ACTIVE GLOW EFFECT */
        .bubble:active {
            filter: brightness(1.1);
        }
        
        /* SENT BUBBLES */
        .sent .bubble { 
            background: var(--sent-bg); 
            color: var(--sent-text); 
            text-align: left; 
            border: 1px solid rgba(255, 255, 255, 0.1); 
            box-shadow: var(--sent-shadow);
        }
        .sent .bubble.single { border-radius: 20px; border-bottom-right-radius: 4px; }
        .sent .bubble.group-top { border-radius: 20px; border-bottom-right-radius: 4px; margin-bottom: 1px; }
        .sent .bubble.group-mid { border-radius: 20px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; margin-bottom: 1px; }
        .sent .bubble.group-bottom { border-radius: 20px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; }

        /* RECEIVED BUBBLES */
        .received .bubble { 
            background: var(--received-bg); 
            color: var(--received-text); 
            text-align: left; 
            border: 1px solid rgba(255,255,255,0.08); 
            box-shadow: var(--received-shadow);
        }
        .received .bubble.single { border-radius: 20px; border-bottom-left-radius: 4px; }
        .received .bubble.group-top { border-radius: 20px; border-bottom-left-radius: 4px; margin-bottom: 1px; }
        .received .bubble.group-mid { border-radius: 20px; border-top-left-radius: 4px; border-bottom-left-radius: 4px; margin-bottom: 1px; }
        .received .bubble.group-bottom { border-radius: 20px; border-top-left-radius: 4px; border-bottom-left-radius: 18px; }

        .bubble a { color: #ffffff; text-decoration: underline; cursor: pointer; font-weight: 600; opacity: 0.9; }
        .received .bubble a { color: var(--accent); }

        /* FIXED TIMESTAMP DISPLAY (Long Press) */
        .msg-timestamp-footer {
            font-size: 0.65rem;
            color: var(--text-secondary);
            font-weight: 500;
            opacity: 0;
            position: absolute;
            bottom: 4px; 
            width: 100%;
            transition: opacity 0.2s ease-in-out;
            pointer-events: none;
        }
        
        .show-timestamps .msg-bubble-box {
            padding-bottom: 18px !important; 
        }
        
        .show-timestamps .msg-timestamp-footer {
            opacity: 1;
        }

        .received .msg-timestamp-footer { text-align: left; left: 4px; }
        .sent .msg-timestamp-footer { text-align: right; right: 4px; }

        .sliding-timestamp { display: none !important; }
        
        /* REACTION BADGE */
        .reaction-badge { 
            position: absolute; 
            bottom: -8px; 
            background: #2a2a2a; 
            border: 2px solid #000; 
            border-radius: 12px; 
            padding: 2px 6px; 
            font-size: 0.8rem; 
            z-index: 20; 
            display: none; 
            cursor: pointer; 
            box-shadow: 0 4px 8px rgba(0,0,0,0.3); 
            min-width: 24px;
            text-align: center;
            will-change: transform;
        }
        .reaction-badge.pop-in {
            animation: popOut 0.4s var(--ease-spring);
        }
        .reaction-badge.updated {
            animation: badgeUpdate 0.3s var(--ease-spring);
        }
        .sent .reaction-badge { right: 0; }
        .received .reaction-badge { left: 0; }
        .sent .reaction-badge { background: #333; color: white; border-color: #000; }

        .seen-status { 
            font-size: 0.65rem; 
            color: var(--text-secondary); 
            margin-top: 2px; 
            margin-right: 2px; 
            text-align: right; 
            font-weight: 500; 
            height: 14px; 
            width: 100%; 
            opacity: 0; 
            animation: fadeStatus 0.4s forwards; 
            position: relative; 
            z-index: 1; 
        }

        /* REPLY ICONS (For Swipe) */
        .swipe-reply-icon {
            position: absolute;
            top: 50%;
            transform: translateY(-50%) scale(0);
            width: 30px; height: 30px;
            background: #333;
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            z-index: 0;
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .swipe-reply-icon svg { width: 16px; height: 16px; fill: #fff; }
        
        .received .swipe-reply-icon { left: -45px; } 
        .sent .swipe-reply-icon { right: -45px; }

        /* Reply Preview Box (Inside Bubble) */
        .reply-box-ui { 
            background: rgba(0, 0, 0, 0.25); 
            padding: 8px 12px; 
            border-radius: 12px; 
            margin-bottom: 6px; 
            font-size: 0.85rem; 
            border-left: 3px solid rgba(255, 255, 255, 0.5); 
            color: rgba(255,255,255,0.9); 
            max-width: 100%; 
            cursor: pointer; 
            overflow: hidden; 
            white-space: nowrap; 
            text-overflow: ellipsis;
            transition: background 0.2s;
        }
        .reply-box-ui:active { background: rgba(0,0,0,0.4); }
        
        /* NOTE REPLY STYLE - UPDATED FROM NOTES.HTML */
        .note-reply-wrapper {
            margin-bottom: 8px;
            display: flex; flex-direction: column; align-items: center;
            max-width: 100%; cursor: pointer;
        }
        
        .note-reply-pill { 
            /* background, color set inline via JS */
            padding: 15px 20px; 
            border-radius: 48px; 
            display: flex; flex-direction: column;
            justify-content: center;
            border: 1px solid rgba(255,255,255,0.15);
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            min-width: 140px; max-width: 240px;
            position: relative;
            transform: scale(0.9);
            text-align: center;
        }
        
        .note-reply-pill.glass {
            background: rgba(255, 255, 255, 0.15) !important;
            backdrop-filter: blur(20px) !important;
            -webkit-backdrop-filter: blur(20px) !important;
            border: 1px solid rgba(255, 255, 255, 0.3) !important;
        }
        
        .note-connector {
            width: 2px; height: 10px; background: rgba(255,255,255,0.2);
            margin-top: -4px; margin-bottom: -4px; z-index: 0;
        }
        
        .note-music-pill {
            display: inline-flex; align-items: center; gap: 6px; 
            background: rgba(0,0,0,0.3); padding: 4px 10px; 
            border-radius: 20px; font-size: 0.65rem; font-weight: 700;
            border: 1px solid rgba(255,255,255,0.2);
            margin-bottom: 4px; width: fit-content;
        }
        
        .note-pfp-sticker {
            width:24px; height:24px; border-radius:50%; border:2px solid rgba(255,255,255,0.2);
        }

        /* Scroll Down Button */
        #scroll-down-btn { 
            position: fixed; 
            bottom: 85px; 
            right: 20px; 
            width: 44px; height: 44px; 
            background: rgba(30, 30, 30, 0.8); 
            border-radius: 50%; 
            display: none; 
            align-items: center; justify-content: center; 
            color: var(--accent); 
            box-shadow: 0 4px 20px rgba(0,0,0,0.4); 
            border: 1px solid rgba(255,255,255,0.1); 
            z-index: 900; 
            cursor: pointer; 
            font-size: 1.2rem; 
            transition: all 0.3s var(--ease-elastic); 
            backdrop-filter: blur(10px);
        }
        #scroll-down-btn.new-msg { 
            background: var(--accent); 
            color: #fff; 
            animation: bounce 1s infinite; 
        }

        /* Heart Pop Animation */
        #heart-overlay { 
            position: fixed; 
            top: 50%; left: 50%; 
            transform: translate(-50%, -50%) scale(0); 
            font-size: 100px; 
            pointer-events: none; 
            z-index: 3000; 
            text-shadow: 0 10px 30px rgba(0,0,0,0.4); 
        }
        
        /* FLOATING EMOJI */
        .floating-emoji {
            position: fixed;
            font-size: 40px;
            pointer-events: none;
            z-index: 3001;
            animation: floatUp 1.2s var(--ease-spring) forwards; /* Improved physics */
            will-change: transform, opacity;
        }

        /* === EFFECT LAYERS (CONFETTI / HEARTS) === */
        #effect-canvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 4000;
        }

        /* =========================================
           9. INPUT AREA (PROFESSIONAL REDESIGN)
           ========================================= */
        .input-area-container { 
            background: rgba(15, 15, 15, 0.85); /* MODIFIED: Sleeker Glassmorphism */
            border-top: 1px solid rgba(255, 255, 255, 0.05); 
            padding-bottom: env(safe-area-inset-bottom, 10px); 
            flex-shrink: 0; 
            width: 100%; 
            z-index: 1000; 
            backdrop-filter: blur(30px);
            -webkit-backdrop-filter: blur(30px);
            position: relative; /* Essential for overlay */
        }
        
        .input-area { 
            padding: 10px 14px; /* MODIFIED: Spacing */
            display: flex; 
            align-items: flex-end; /* MODIFIED: Bottom alignment */
            gap: 12px; 
        }
        
        .input-box { 
            flex: 1; 
            background: rgba(255, 255, 255, 0.08); /* MODIFIED: Clean pill container */
            border-radius: 26px; /* MODIFIED: Perfect pill shape */
            padding: 6px 16px; 
            border: 1px solid transparent; 
            display: flex; 
            align-items: center; 
            min-height: 44px; 
            transition: border-color 0.2s, background 0.2s, box-shadow 0.3s ease; 
        }
        .input-box:focus-within { 
            border-color: rgba(255, 109, 0, 0.5); /* MODIFIED: Subtle brand border */
            background: rgba(255, 255, 255, 0.12); 
        }

        .msg-input { 
            width: 100%; 
            background: transparent; 
            border: none; 
            color: white; 
            padding: 8px 0; /* MODIFIED */
            font-size: 15px; /* MODIFIED */
            resize: none; 
            max-height: 140px; 
            overflow-y: auto; 
            line-height: 1.4; 
        }
        
        .plus-btn { 
            background: rgba(255, 255, 255, 0.1); /* MODIFIED: Solid subtle button */
            border-radius: 50%;
            font-size: 24px; 
            color: var(--accent); 
            cursor: pointer; 
            height: 36px; /* MODIFIED */
            width: 36px;  /* MODIFIED */
            display: flex; 
            align-items: center; 
            justify-content: center;
            align-self: flex-end; /* MODIFIED */
            margin-bottom: 4px; /* MODIFIED */
            transition: transform 0.2s var(--ease-elastic), background 0.2s; 
        }
        .plus-btn:active { transform: rotate(90deg); background: rgba(255,255,255,0.2); }
        
        .send-btn { 
            background: transparent; 
            border: none; 
            font-weight: 700; 
            font-size: 1rem; 
            padding: 0 4px; 
            height: 44px; 
            display: none; 
            align-items: center; 
            color: #555; 
            pointer-events: none; 
            transition: all 0.2s ease; 
            align-self: flex-end; /* MODIFIED */
            margin-bottom: 0px; /* MODIFIED */
        }
        .send-btn.active { 
            color: var(--accent); 
            cursor: pointer; 
            pointer-events: auto; 
            text-shadow: 0 0 15px rgba(255, 109, 0, 0.4); 
            transform: scale(1.05);
            display: flex !important;
        }

        /* === MIC BUTTON & RECORDING UI === */
        .mic-btn-wrapper {
            width: 44px; height: 44px;
            display: flex; align-items: center; justify-content: center;
            position: relative;
            z-index: 100;
            align-self: flex-end; /* MODIFIED */
        }

        .mic-btn {
            width: 44px; height: 44px;
            display: flex; align-items: center; justify-content: center;
            border-radius: 50%;
            background: transparent; color: var(--accent); /* MODIFIED: Cleaner mic */
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            -webkit-user-select: none; user-select: none;
            touch-action: none; 
        }
        .mic-btn svg { width: 26px; height: 26px; fill: currentColor; pointer-events: none; }
        
        .mic-btn.recording {
            transform: scale(1.5);
            background: #ff453a;
            color: white;
            box-shadow: 0 0 20px rgba(255, 69, 58, 0.5);
        }
        .mic-btn.locked {
             transform: scale(1); background: #ff453a; color: white;
        }

        .recording-ui-overlay {
            position: absolute; left: 0; bottom: 0; width: 100%; height: 100%;
            background: var(--bg); 
            display: none; align-items: center; padding: 0 16px; z-index: 50;
        }
        
        .rec-timer {
            font-family: monospace; font-size: 1.1rem; color: #ff453a; font-weight: 600; min-width: 60px;
        }
        
        .rec-visualizer {
            flex: 1; height: 30px; display: flex; align-items: center; gap: 3px; margin: 0 15px; opacity: 0.6;
            overflow: hidden;
            mask-image: linear-gradient(to right, transparent, black 10%, black 90%, transparent);
            -webkit-mask-image: linear-gradient(to right, transparent, black 10%, black 90%, transparent);
        }
        .viz-bar { width: 4px; background: #ff453a; border-radius: 2px; animation: vizAnim 0.5s infinite ease-in-out; }
        @keyframes vizAnim { 0%,100% { height: 20%; } 50% { height: 100%; } }
        
        .rec-slide-cancel-text {
            position: absolute; 
            right: 70px; 
            top: 50%; 
            transform: translateY(-50%);
            left: auto; 
            color: #888; font-size: 0.9rem; font-weight: 500;
            pointer-events: none;
            display: flex; align-items: center; gap: 6px;
            opacity: 0; transition: opacity 0.3s;
            white-space: nowrap;
            background: rgba(0,0,0,0.6); 
            padding: 4px 8px; border-radius: 12px;
        }
        .rec-slide-cancel-text svg { width: 16px; height: 16px; fill: #888; }
        
        .lock-indicator-pill {
            position: absolute; bottom: 80px; right: 12px;
            background: rgba(30,30,30,0.9); backdrop-filter: blur(10px);
            padding: 8px 12px; border-radius: 20px;
            color: white; font-size: 0.8rem;
            display: flex; flex-direction: column; align-items: center; gap: 4px;
            transform: translateY(20px); opacity: 0; transition: all 0.3s;
            pointer-events: none; z-index: 90;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .lock-indicator-pill.visible { transform: translateY(0); opacity: 1; }
        .lock-arrow { width: 14px; height: 14px; fill: white; animation: bounceUp 1s infinite; }
        @keyframes bounceUp { 0%,100%{transform:translateY(0);} 50%{transform:translateY(-4px);} }

        .cancel-trash-zone {
            position: absolute; bottom: 10px; left: 20px;
            width: 50px; height: 50px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            background: #1a1a1a; color: #888;
            transform: scale(0); transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 101;
        }
        .cancel-trash-zone.visible { transform: scale(1); }
        .cancel-trash-zone.active { transform: scale(1.3); background: #ff453a; color: white; }
        .cancel-trash-zone svg { width: 24px; height: 24px; fill: currentColor; }

        .rec-ind-bubble {
            background: var(--received-bg);
            padding: 8px 14px;
            border-radius: 18px;
            border-bottom-left-radius: 4px;
            display: flex; align-items: center; gap: 8px;
            height: 38px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.05);
            color: #ff453a; font-size: 0.85rem; font-weight: 600;
        }
        .rec-wave-icon { display: flex; gap: 2px; align-items: center; height: 12px; }
        .rec-wave-bar { width: 2px; height: 100%; background: #ff453a; animation: recWaveBody 1s infinite ease-in-out; }
        .rec-wave-bar:nth-child(2) { animation-delay: 0.1s; height: 60%; }
        .rec-wave-bar:nth-child(3) { animation-delay: 0.2s; height: 80%; }
        @keyframes recWaveBody { 0%,100% { transform: scaleY(0.5); } 50% { transform: scaleY(1); } }


        /* EMOJI & ATTACHMENT MENUS */
        #emoji-tray { display: none; background: #000; border-top: 1px solid var(--border); height: 280px; padding: 0; }
        
        #attachment-menu {
            display: none; 
            position: absolute; 
            bottom: 75px; 
            left: 16px;
            background: rgba(30, 30, 30, 0.95); 
            backdrop-filter: blur(15px);
            border-radius: 18px; 
            padding: 8px; 
            z-index: 1001;
            box-shadow: 0 10px 40px rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.1);
            animation: slideUpFade 0.25s var(--ease-elastic);
            flex-direction: column; 
            gap: 4px; 
            width: 180px;
        }
        @keyframes slideUpFade { from { opacity: 0; transform: translateY(20px) scale(0.9); } to { opacity: 1; transform: translateY(0) scale(1); } }
        
        .attach-opt { 
            display: flex; 
            align-items: center; 
            gap: 12px; 
            padding: 12px 14px; 
            border-radius: 12px; 
            cursor: pointer; 
            color: white; 
            font-size: 0.95rem; 
            font-weight: 500; 
            transition: background 0.2s;
        }
        .attach-opt:active { background: rgba(255,255,255,0.1); }
        .attach-opt svg { width: 24px; height: 24px; fill: #eee; }

        /* OVERLAYS */
        #menu-overlay, #reaction-details-overlay { 
            display: none; position: fixed; inset: 0; 
            background: rgba(0, 0, 0, 0.7); z-index: 2000; 
            justify-content: center; align-items: center; 
            backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px);
            animation: fadeInOverlay 0.2s ease;
        }
        @keyframes fadeInOverlay { from { opacity: 0; } to { opacity: 1; } }

        .menu-card { 
            background: #1c1c1c; 
            border-radius: 20px; 
            width: 280px; 
            overflow: hidden; 
            box-shadow: 0 20px 50px rgba(0,0,0,0.7); 
            border: 1px solid rgba(255,255,255,0.1);
            transform: scale(0.9);
            animation: scaleIn 0.2s forwards;
        }
        
        .reaction-bar { 
            display: flex; 
            justify-content: space-evenly; 
            padding: 18px 10px; 
            border-bottom: 1px solid #333; 
            background: #222;
        }
        .reaction-bar span { font-size: 2rem; cursor: pointer; transition: transform 0.1s var(--ease-elastic); }
        .reaction-bar span:active { transform: scale(1.4); }
        
        .more-emoji-trigger { 
            background: #333; 
            border-radius: 50%; 
            width: 38px; height: 38px; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-size: 20px; 
            color: #fff; 
            cursor: pointer; 
        }

        .menu-opt { 
            padding: 16px; 
            text-align: center; 
            font-size: 1rem; 
            border-bottom: 1px solid #2a2a2a; 
            color: #fff; 
            font-weight: 500;
        }
        .menu-opt:active { background: #333; }
        
        #reply-dock { 
            display: none; 
            background: #161616; 
            padding: 12px 16px; 
            border-top: 1px solid var(--border); 
            justify-content: space-between; 
            align-items: center; 
            animation: slideUp 0.2s ease;
        }

        /* MEDIA MESSAGES */
        .msg-media-wrapper {
            position: relative;
            cursor: pointer; 
            margin-bottom: 2px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.4);
            border-radius: 18px;
            overflow: visible; 
        }
        
        .chat-media-img {
            display: block; 
            width: 100%; 
            max-width: 280px; 
            max-height: 380px; 
            object-fit: cover; 
            border-radius: 18px; 
            animation: imgFadeIn 0.3s ease-out; 
            background: #111;
        }
        
        /* Media Corner Logic */
        .sent .msg-media-wrapper.group-top .chat-media-img { border-bottom-right-radius: 4px; }
        .sent .msg-media-wrapper.group-mid .chat-media-img { border-top-right-radius: 4px; border-bottom-right-radius: 4px; }
        .sent .msg-media-wrapper.group-bottom .chat-media-img { border-top-right-radius: 4px; border-bottom-right-radius: 18px; }
        
        .received .msg-media-wrapper.group-top .chat-media-img { border-bottom-left-radius: 4px; }
        .received .msg-media-wrapper.group-mid .chat-media-img { border-top-left-radius: 4px; border-bottom-left-radius: 4px; }
        .received .msg-media-wrapper.group-bottom .chat-media-img { border-top-left-radius: 4px; border-bottom-left-radius: 18px; }


        .bubble.has-media {
            border-top-left-radius: 4px; border-top-right-radius: 4px;
            margin-top: 2px;
        }

        /* AUDIO & FILE STYLES */
        .msg-video-container {
            position: relative;
            max-width: 280px; border-radius: 18px;
            overflow: hidden;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            background: #000;
        }
        .play-overlay {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 50px; height: 50px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255,255,255,0.3);
            pointer-events: none;
        }
        
        /* UPDATED AUDIO UI - BIGGER */
        .msg-audio-pill {
            display: flex; align-items: center; gap: 12px;
            padding: 4px 12px;
            background: linear-gradient(135deg, #2a2a2a, #333);
            border-radius: 24px;
            min-width: 260px; /* Bigger */
            height: 60px; /* Taller */
            border: 1px solid rgba(255,255,255,0.1);
            position: relative;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        .audio-control-btn {
            width: 42px; height: 42px; /* Bigger button */
            background: var(--accent); border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            color: #000; cursor: pointer; flex-shrink: 0;
            z-index: 5;
            box-shadow: 0 2px 6px rgba(0,0,0,0.4);
            transition: transform 0.1s;
            pointer-events: auto; /* Ensure clickable */
        }
        .audio-control-btn:active { transform: scale(0.9); }
        .audio-control-btn svg { width: 20px; height: 20px; fill: #fff; }
        
        .audio-speed-btn {
            background: rgba(255,255,255,0.15);
            border-radius: 12px;
            padding: 6px 10px;
            font-size: 0.8rem;
            color: #ddd;
            cursor: pointer;
            font-weight: 700;
            min-width: 45px;
            text-align: center;
        }
        
        /* VISUALIZER */
        .audio-wave-container {
            flex: 1; display: flex; align-items: center; gap: 3px; height: 30px; overflow: hidden;
            position: relative;
            mask-image: linear-gradient(to right, transparent, black 5%, black 95%, transparent);
            -webkit-mask-image: linear-gradient(to right, transparent, black 5%, black 95%, transparent);
        }
        .wave-bar {
            width: 4px; background: #777; border-radius: 2px;
            height: 40%; transition: height 0.1s;
        }
        .audio-playing .wave-bar {
            background: var(--accent);
            animation: waveAnim 0.8s ease-in-out infinite;
        }
        .audio-playing .wave-bar:nth-child(odd) { animation-duration: 0.6s; }
        .audio-playing .wave-bar:nth-child(2n) { animation-duration: 1.1s; }
        
        @keyframes waveAnim { 0% { height: 30%; } 50% { height: 100%; } 100% { height: 30%; } }

        .msg-file-pill {
            display: flex; align-items: center; gap: 12px;
            padding: 12px 14px;
            background: #262626;
            border-radius: 16px;
            min-width: 210px; max-width: 260px;
            border: 1px solid rgba(255,255,255,0.1);
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .file-icon {
            width: 42px; height: 42px;
            background: #333; border-radius: 10px;
            display: flex; align-items: center; justify-content: center;
            font-size: 1.5rem; flex-shrink: 0;
        }

        /* REACTION LIST MODAL */
        .react-list-container { width: 85%; max-width: 340px; background: #1c1c1c; border-radius: 20px; overflow: hidden; display: flex; flex-direction: column; max-height: 50vh; }
        .react-list-header { padding: 18px; text-align: center; font-weight: 600; font-size: 1.1rem; border-bottom: 1px solid #333; position: relative; color: white;}
        .react-list-close { position: absolute; right: 18px; top: 18px; cursor: pointer; color: #888; }
        .reactor-item { display: flex; align-items: center; padding: 14px 18px; gap: 14px; border-bottom: 1px solid #2a2a2a; }
        .reactor-pfp { width: 44px; height: 44px; border-radius: 50%; object-fit: cover; background: #333; }
        .reactor-info { flex: 1; }
        .reactor-name { font-weight: 600; font-size: 0.95rem; color: #fff; }
        .reactor-time { font-size: 0.75rem; color: #888; margin-top: 2px; }
        .reactor-emoji { font-size: 1.6rem; }

        /* REACTION HALF-SCREEN MODAL */
        #reaction-picker-modal {
            display: none; position: fixed; inset: 0; z-index: 3000;
            background: rgba(0,0,0,0.6); backdrop-filter: blur(3px);
            align-items: flex-end; 
        }
        .picker-modal-content {
            width: 100%; height: 50vh; 
            background: #181818;
            border-top-left-radius: 24px; border-top-right-radius: 24px;
            display: flex; flex-direction: column;
            animation: slideUp 0.35s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            overflow: hidden;
            border-top: 1px solid #333;
        }
        .picker-header {
            padding: 16px; display: flex; align-items: center; gap: 12px;
            border-bottom: 1px solid #333; color: white; font-weight: 600; font-size: 1.1rem;
        }
        .picker-drag-handle {
            width: 40px; height: 5px; background: #444; border-radius: 10px; margin: 0 auto;
        }

        /* RIPPLE EFFECT */
        .ripple {
            position: absolute;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0);
            animation: rippleAnim 0.6s linear;
            pointer-events: none;
        }
        @keyframes rippleAnim {
            to { transform: scale(4); opacity: 0; }
        }

    </style>
</head>
<body>

<image-picker id="img-picker"></image-picker>
<file-picker id="file-picker"></file-picker>
<view-media id="media-viewer"></view-media>

<div id="blocked-banner" style="display:none; position:fixed; bottom:0; width:100%; background:#1a1a1a; color:#888; text-align:center; padding:20px; font-weight:500; z-index:1001; border-top:1px solid #333;">
    You cannot message this account.
</div>

<div id="pulse-invite-banner">
    <div class="invite-content">
        <span class="material-icons-round invite-pulse-icon">graphic_eq</span>
        <span>Invited you to a Pulse Session</span>
    </div>
    <div class="invite-actions">
        <button class="btn-dismiss" onclick="dismissPulseInvite()"></button>
        <button class="btn-join" onclick="joinPulseSession()">JOIN</button>
    </div>
</div>

<div id="heart-overlay"></div>
<canvas id="effect-canvas"></canvas>

<div id="scroll-down-btn" onclick="scrollToBottom(true)"></div> <div id="reaction-details-overlay" onclick="closeReactionDetails()">
    <div class="react-list-container" onclick="event.stopPropagation()">
        <div class="react-list-header">
            Reactions
            <div class="react-list-close" onclick="closeReactionDetails()"></div>
        </div>
        <div class="react-list-content" id="react-list-items"></div>
    </div>
</div>

<div id="reaction-picker-modal" onclick="closeReactionPicker()">
    <div class="picker-modal-content" onclick="event.stopPropagation()">
        <div style="padding:12px 0 6px 0;"><div class="picker-drag-handle"></div></div>
        <div class="picker-header">
            <span onclick="closeReactionPicker()" style="font-size:1.4rem; cursor:pointer; padding:0 10px;"></span>
            React
        </div>
        <div id="reaction-picker-container" style="flex:1; overflow:hidden;"></div>
    </div>
</div>

<div id="menu-overlay" onclick="closeMenu()">
    <div class="menu-card" id="main-menu-card" onclick="event.stopPropagation()">
        <div class="reaction-bar">
            <span onclick="applyReaction('')"></span>
            <span onclick="applyReaction('')"></span>
            <span onclick="applyReaction('')"></span>
            <span onclick="applyReaction('')"></span>
            <span onclick="applyReaction('')"></span>
            <div class="more-emoji-trigger" onclick="expandEmojiMenu()">+</div>
        </div>
        <div id="menu-emoji-grid"></div>
        
        <div class="menu-opt" onclick="copyMessageText()">Copy Text</div>
        <div class="menu-opt" onclick="initReplyFromActive()">Reply</div>
        <div id="edit-btn" class="menu-opt" onclick="initEdit()">Edit</div>
        <div id="unsend-btn" class="menu-opt" style="color:#ff453a; font-weight: 600;" onclick="unsendMsg()">Unsend</div>
        <div class="menu-opt" onclick="closeMenu()" style="border-bottom:none; color: #888">Cancel</div>
    </div>
</div>

<div class="app-container" id="main-app">
    <header id="chat-header">
        <div class="back-btn" onclick="history.back()">
            <span class="material-icons-round" style="font-size: 32px; font-weight: 500;">chevron_left</span>
        </div>
        <div class="h-profile-group" onclick="goToProfile()">
            <div class="pfp-container">
                <img id="h-pfp" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class="h-pfp loading-shimmer">
                <div class="online-dot" id="h-online-dot"></div>
            </div>
            <div class="h-info">
                <div class="h-name-wrapper">
                    <div class="h-name" id="h-display-name"></div>
                    <img id="v-badge" class="v-badge" src="data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='%231DA1F2' d='M22.5 12.5c0-1.58-.875-2.95-2.148-3.6.154-.435.238-.905.238-1.4 0-2.21-1.71-3.998-3.818-3.998-.47 0-.92.084-1.336.25C14.818 2.415 13.51 1.5 12 1.5s-2.816.917-3.437 2.25c-.415-.165-.866-.25-1.336-.25-2.11 0-3.818 1.79-3.818 4 0 .495.083.965.238 1.4-1.272.65-2.147 2.02-2.147 3.6 0 1.457.746 2.74 1.863 3.494C2.988 16.68 2.66 17.59 2.66 18.5c0 2.11 1.81 3.818 3.962 3.818.84 0 1.624-.306 2.23-.83-.015.108-.02.217-.02.327 0 1.34 1.438 2.43 3.21 2.43s3.213-1.09 3.213-2.43c0-.11-.005-.218-.02-.327.605.524 1.39.83 2.23.83 2.15 0 3.96-1.71 3.96-3.82 0-.91-.328-1.82-.704-2.505 1.117-.754 1.864-2.037 1.864-3.494z'/%3E%3Cpath fill='%23000000' d='M10.135 16.253l-3.32-3.46c-.39-.407-.377-1.054.03-1.444.406-.39 1.053-.377 1.443.03l2.03 2.114 4.86-6.52c.337-.453.977-.545 1.43-.208.453.337.545.977.208 1.43l-5.6 7.51c-.2.27-.516.425-.852.418-.337-.007-.647-.18-.83-.47z'/%3E%3C/svg%3E">

                </div>
                <div class="h-username-sub" id="h-username-label"></div>
            </div>
        </div>
        <div class="header-actions">
            <div class="header-icon pulse-icon" onclick="goToPulse()">
                <span class="material-icons-round">graphic_eq</span>
            </div>
            <div class="header-icon" onclick="window.location.href='calls.html'">
                <span class="material-icons-round">call</span>
            </div>
            <div class="header-icon" onclick="window.location.href='calls.html'">
                <span class="material-icons-round">videocam</span>
            </div>
        </div>
    </header>

    <div id="chat-flow">
        <div id="scroll-trigger"></div>
        
        <div id="messages-container"></div>
        
        <div class="typing-row" id="typing-row">
             <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class="typing-avatar" id="typing-pfp">
             <div class="typing-bubble" id="typing-bubble-content">
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
             </div>
        </div>
    </div>

    <div class="input-area-container">
        
        <div id="recording-overlay" class="recording-ui-overlay">
            <div class="rec-dot" style="width:10px;height:10px;background:#ff453a;border-radius:50%;margin-right:8px;animation:pulseGreen 1s infinite;"></div>
            <div class="rec-timer" id="rec-timer">0:00</div>
            <div class="rec-visualizer">
                <div class="viz-bar" style="animation-delay:0.1s"></div>
                <div class="viz-bar" style="animation-delay:0.2s"></div>
                <div class="viz-bar" style="animation-delay:0.3s"></div>
                <div class="viz-bar" style="animation-delay:0.4s"></div>
                <div class="viz-bar" style="animation-delay:0.5s"></div>
                <div class="viz-bar" style="animation-delay:0.2s"></div>
                <div class="viz-bar" style="animation-delay:0.1s"></div>
                <div class="viz-bar" style="animation-delay:0.3s"></div>
                <div class="viz-bar" style="animation-delay:0.4s"></div>
                <div class="viz-bar" style="animation-delay:0.1s"></div>
            </div>
            <div class="rec-slide-cancel-text" id="rec-cancel-text">
                <span class="material-icons-round" style="font-size:16px;">chevron_left</span> 
                Slide to cancel
            </div>
        </div>
        
        <div class="lock-indicator-pill" id="lock-pill">
            <span class="material-icons-round lock-arrow">keyboard_arrow_up</span>
            <span class="material-icons-round" style="font-size:16px;">lock</span>
        </div>

        <div class="cancel-trash-zone" id="cancel-trash">
            <span class="material-icons-round">delete</span>
        </div>

        <div id="reply-dock">
            <div style="flex:1;">
                <div id="reply-text" style="font-size:0.85rem; color:#ccc; overflow:hidden; text-overflow:ellipsis;"></div>
            </div>
            <div onclick="cancelInteraction()" style="color:#fff; font-weight:bold; padding:8px; cursor:pointer;"></div>
        </div>

        <div id="emoji-tray">
             <emoji-picker id="main-picker" style="width:100%; height:100%;"></emoji-picker>
        </div>

        <div id="attachment-menu">
            <div class="attach-opt" onclick="openCameraPicker()">
                <span class="material-icons-round">photo_camera</span>
                <span>Camera / Gallery</span>
            </div>
            <div class="attach-opt" onclick="openFilePicker()">
                <span class="material-icons-round">attach_file</span>
                <span>File / Video</span>
            </div>
            <div class="attach-opt" onclick="toggleEmojiTray()">
                <span class="material-icons-round">emoji_emotions</span>
                <span>Emoji</span>
            </div>
        </div>

        <div class="input-area">
            <div class="plus-btn" onclick="toggleAttachmentMenu()">+</div>
            <div class="input-box" id="msg-input-box">
                <textarea id="m-input" class="msg-input" placeholder="Message..." rows="1"></textarea>
            </div>
            <button id="send-btn" class="send-btn">Send</button>
            <div id="mic-btn-wrapper" class="mic-btn-wrapper">
                <div id="mic-btn" class="mic-btn">
                    <span class="material-icons-round">mic</span>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    // =========================================
    //  NEW: INBOX CACHE UPDATER
    // =========================================
    // Keeps the inbox perfectly synced without loading
    function updateInboxCacheLocal(chatIdToUpdate, newText, senderId, isUnread) {
        try {
            let cachedInboxHTML = localStorage.getItem('goorac_inbox_html');
            if (!cachedInboxHTML) return;
            let tempDiv = document.createElement('div');
            tempDiv.innerHTML = cachedInboxHTML;

            let nameSpan = tempDiv.querySelector(`#name-${chatIdToUpdate}`);
            if (nameSpan) {
                let chatItem = nameSpan.closest('.chat-item');
                let lastMsgDiv = chatItem.querySelector(`#last-msg-${chatIdToUpdate}`);
                if (lastMsgDiv) {
                    lastMsgDiv.innerHTML = newText;
                    if (isUnread) {
                        lastMsgDiv.style.color = '#fff';
                        lastMsgDiv.style.fontWeight = '700';
                        let metaDiv = chatItem.querySelector(`#meta-${chatIdToUpdate}`);
                        if (metaDiv && !metaDiv.querySelector('.unread-badge')) {
                            let badgeHtml = `<div class="unread-badge" style="background:#00d2ff; box-shadow: 0 0 12px #00d2ff;"></div>`;
                            metaDiv.insertAdjacentHTML('beforeend', badgeHtml);
                        }
                    } else {
                        lastMsgDiv.style.color = 'var(--text-dim)';
                        lastMsgDiv.style.fontWeight = 'normal';
                        let badge = chatItem.querySelector('.unread-badge');
                        if (badge) badge.remove();
                    }
                }
                let list = chatItem.parentNode;
                if(list && list.firstChild !== chatItem) {
                    list.insertBefore(chatItem, list.firstChild);
                }
                localStorage.setItem('goorac_inbox_html', tempDiv.innerHTML);
            }
        } catch(e) { console.error("Inbox Cache Error", e); }
    }

    // =========================================
    //  10. FIREBASE INITIALIZATION
    // =========================================
    
    // Updated to use external config.js (window.firebaseConfig)
    let fbConfig = (typeof window.firebaseConfig !== 'undefined') ? window.firebaseConfig : {
        // Fallback or empty if config.js missing
    };

    if (!firebase.apps.length && fbConfig.apiKey) {
        firebase.initializeApp(fbConfig);
    }
    const db = firebase.firestore();
    const rdb = firebase.database();
    const auth = firebase.auth();
    
    // Attempt to enable offline persistence
    db.enablePersistence().catch(err => {
        console.log("Persistence disabled:", err.code);
    });

    // =========================================
    //  11. GLOBAL STATE VARIABLES
    // =========================================
    const params = new URLSearchParams(window.location.search);
    const targetUsername = params.get('user');
    
    let myUid, targetUid, chatId, replyingTo = null, editModeId = null;
    let activeMenuId = null, unsubscribe = null, isLoadingMore = false;
    let lastVisible = null; 
    let messagesMap = new Map(); 
    let chatTargetData = null; 
    let myUserData = null;
    let isFirstLoad = true;
    let statusTimeout = null;
    let pulseListener = null;
    
    // Status Logic State
    let lastStatusData = null;
    let statusUpdateInterval = null;
    let isFirstStatusLoad = true; 

    // Audio SFX
    const popSound = new Audio("data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU"); 
    const likeSound = new Audio("data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU"); 

    // DOM References
    const mInput = document.getElementById('m-input');
    const inputBox = document.getElementById('msg-input-box');
    const chatFlow = document.getElementById('chat-flow');
    let container = document.getElementById('messages-container');
    const typingRow = document.getElementById('typing-row');
    const typingPfp = document.getElementById('typing-pfp');
    const emojiTray = document.getElementById('emoji-tray');
    const scrollBtn = document.getElementById('scroll-down-btn');
    const sendBtnUI = document.getElementById('send-btn');
    const onlineDot = document.getElementById('h-online-dot');
    const headerSubLabel = document.getElementById('h-username-label');
    const attachmentMenu = document.getElementById('attachment-menu');
    const micBtn = document.getElementById('mic-btn');
    const micWrapper = document.getElementById('mic-btn-wrapper');

    // =========================================
    //  12. INSTANT LOAD / 0ms RENDER
    // =========================================
    (function instantRender() {
        const storedMyUid = localStorage.getItem('my_uid_cache');
        const userCacheKey = `chat_user_${targetUsername}`;
        const storedUser = localStorage.getItem(userCacheKey);

        if (storedUser && storedMyUid && targetUsername) {
            try {
                // 1. Render Header Instantly (NAME & PFP Only - NOT Status)
                chatTargetData = JSON.parse(storedUser);
                const pfp = document.getElementById('h-pfp');
                pfp.classList.remove('loading-shimmer');
                pfp.src = chatTargetData.photoURL || 'https://via.placeholder.com/150';
                document.getElementById('h-display-name').innerText = chatTargetData.name || chatTargetData.username;
                
                // Set default label to username initially (Prevents showing old status)
                document.getElementById('h-username-label').innerText = `@${chatTargetData.username}`;
                
                if(chatTargetData.verified === true) {
                    document.getElementById('v-badge').style.display = 'block';
                } else {
                    document.getElementById('v-badge').style.display = 'none';
                }

                // 2. Setup IDs
                myUid = storedMyUid; 
                targetUid = chatTargetData.uid;
                chatId = myUid < targetUid ? `${myUid}_${targetUid}` : `${targetUid}_${myUid}`;

                // 3. Render Cached Messages
                const msgCacheKey = `chat_msgs_${chatId}`;
                const storedMsgs = localStorage.getItem(msgCacheKey);
                
                if (storedMsgs) {
                    const msgs = JSON.parse(storedMsgs);
                    msgs.forEach(m => {
                        m.timestamp = { toDate: () => new Date(m.timestampIso || m.timestamp) };
                        if(m.seenAtIso) m.seenAt = { toDate: () => new Date(m.seenAtIso) };
                        messagesMap.set(m.id || m.timestampIso, m);
                    });
                    
                    document.body.classList.add('instant-load');
                    renderAll();
                    
                    chatFlow.style.opacity = '1';
                    chatFlow.scrollTop = chatFlow.scrollHeight;
                    isFirstLoad = false;
                }
            } catch(e) { console.error("Instant Load Error", e); }
        }
    })();

    // =========================================
    //  13. EVENT LISTENERS & INTERACTION
    // =========================================
    
    // Double Tap Background to Scroll
    document.addEventListener('dblclick', (e) => {
        if (e.target.id === 'chat-flow' || e.target.id === 'messages-container') {
            scrollToBottom(true); /* MODIFIED: Call smooth scroll */
            vibrate(30);
        }
    });
    
    // Ripple Effect Logic
    document.addEventListener('click', function(e) {
        // Auto-close attachment menu
        if (!e.target.closest('#attachment-menu') && !e.target.closest('.plus-btn')) {
            if (attachmentMenu.style.display === 'flex') closeAttachmentMenu();
        }
        
        // Don't ripple on inputs or mic button
        if(e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.closest('emoji-picker') || e.target.closest('.mic-btn')) return;
        
        const circle = document.createElement('div');
        const diameter = 30;
        const radius = diameter / 2;
        circle.style.width = circle.style.height = `${diameter}px`;
        circle.style.left = `${e.clientX - radius}px`;
        circle.style.top = `${e.clientY - radius}px`;
        circle.classList.add('ripple');
        document.body.appendChild(circle);
        setTimeout(() => circle.remove(), 600);
    });
    
    // Send Button Touch Handling
    const handleSendClick = (e) => {
        e.preventDefault(); 
        sendMsg();
    };
    sendBtnUI.addEventListener('mousedown', handleSendClick);
    sendBtnUI.addEventListener('touchstart', handleSendClick);

    // Auto-Resize Textarea
    mInput.addEventListener('input', function() {
        this.style.height = 'auto'; 
        this.style.height = (this.scrollHeight) + 'px';
        if(this.value === '') this.style.height = 'auto';
        
        // Toggle Send / Mic Button
        if(this.value.trim().length > 0) {
            sendBtnUI.classList.add('active');
            micWrapper.style.display = 'none';
            // Send Typing Indicator
            rdb.ref(`typing/${chatId}/${myUid}`).set(true);
        } else {
            sendBtnUI.classList.remove('active');
            micWrapper.style.display = 'flex';
            rdb.ref(`typing/${chatId}/${myUid}`).set(false);
        }
        
        // Auto-Scroll on Typing
        if(chatFlow.scrollHeight - chatFlow.scrollTop - chatFlow.clientHeight < 120) {
             scrollToBottom();
        }
    });

    // Scroll Observer for "New Message" Button & Load More Fix
    chatFlow.addEventListener('scroll', () => {
        const diff = chatFlow.scrollHeight - chatFlow.scrollTop - chatFlow.clientHeight;
        if (diff > 300) {
            scrollBtn.style.display = 'flex';
        } else {
            scrollBtn.style.display = 'none';
            scrollBtn.classList.remove('new-msg');
        }
        
        // FIX: Reliable top scroll detection for older messages
        if (chatFlow.scrollTop < 150 && !isLoadingMore && lastVisible) {
            loadMoreMessages();
        }
    });

    // Disable Context Menu (Right Click) but allow Paste
    window.oncontextmenu = (e) => { 
        if(e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return true;
        e.preventDefault(); 
        return false; 
    };
    
    // =========================================
    //  14. COMPONENT INTEGRATION
    // =========================================
    const mainPicker = document.getElementById('main-picker');
    const imagePickerComponent = document.getElementById('img-picker');
    const filePickerComponent = document.getElementById('file-picker');

    if(mainPicker) {
        mainPicker.addEventListener('emoji-click', event => {
            const emoji = event.detail.emoji || event.detail.unicode; 
            mInput.value += emoji;
            mInput.focus();
            mInput.dispatchEvent(new Event('input'));
        });
    }

    if (imagePickerComponent) {
        imagePickerComponent.addEventListener('image-uploaded', (e) => {
            const url = e.detail.url;
            if (url) sendImageMessage(url);
        });
    }

    if (filePickerComponent) {
        filePickerComponent.addEventListener('file-uploaded', (e) => {
            const { url, metadata } = e.detail;
            if (url) sendFileMessage(url, metadata);
        });
    }

    // UI Toggles with History State for Back Button
    function toggleAttachmentMenu() {
        if (attachmentMenu.style.display === 'flex') {
            closeAttachmentMenu();
        } else {
            emojiTray.style.display = 'none'; 
            attachmentMenu.style.display = 'flex';
            pushModalState('attachment');
        }
    }
    
    function closeAttachmentMenu() {
        if(attachmentMenu.style.display === 'flex') {
            attachmentMenu.style.display = 'none';
            if(history.state && history.state.modal === 'attachment') history.back();
        }
    }

    function openCameraPicker() {
        closeAttachmentMenu();
        if (imagePickerComponent) imagePickerComponent.openPicker();
    }

    function openFilePicker() {
        closeAttachmentMenu();
        if (filePickerComponent) filePickerComponent.openPicker();
    }

    function toggleEmojiTray() {
        attachmentMenu.style.display = 'none'; 
        if (emojiTray.style.display === 'block') {
            emojiTray.style.display = 'none';
            if(history.state && history.state.modal === 'emoji') history.back();
        } else {
            emojiTray.style.display = 'block';
            scrollToBottom();
            pushModalState('emoji');
        }
    }
    
    // Reaction Picker (Half Screen)
    function expandEmojiMenu() {
        const overlay = document.getElementById('menu-overlay');
        if(overlay.style.display === 'flex') {
            overlay.style.display = 'none';
            history.replaceState({modal: 'reactionPicker'}, null, "");
        } else {
            pushModalState('reactionPicker');
        }
        
        const reactionModal = document.getElementById('reaction-picker-modal');
        const container = document.getElementById('reaction-picker-container');
        container.innerHTML = ''; 
        
        const reactionPicker = document.createElement('emoji-picker');
        reactionPicker.style.width = "100%";
        reactionPicker.style.height = "100%";
        reactionPicker.addEventListener('emoji-click', event => {
             const emoji = event.detail.emoji || event.detail.unicode;
             applyReaction(emoji);
             closeReactionPicker(); 
        });
        container.appendChild(reactionPicker);
        reactionModal.style.display = 'flex';
    }

    function closeReactionPicker() {
        const modal = document.getElementById('reaction-picker-modal');
        if (modal.style.display === 'flex') {
            modal.style.display = 'none';
            if(history.state && history.state.modal === 'reactionPicker') history.back();
        }
    }

    // Viewport Handling for Mobile Keyboards
    if (window.visualViewport) {
        window.visualViewport.addEventListener('resize', () => {
            const viewportHeight = window.visualViewport.height;
            document.getElementById('main-app').style.height = viewportHeight + 'px';
            document.body.style.top = window.visualViewport.offsetTop + 'px';
            scrollToBottom();
        });
    }

    function vibrate(ms = 50) { if (navigator.vibrate) navigator.vibrate(ms); }
    function goToProfile() { if(targetUsername) window.location.href = `userProfile.html?user=${targetUsername}`; }
    function goToPulse() { if(targetUsername) window.location.href = `pulse.html?user=${targetUsername}`; }
    
    mInput.addEventListener("focus", () => { 
        if(emojiTray.style.display === 'block') closeEmojiTray();
        if(attachmentMenu.style.display === 'flex') closeAttachmentMenu();
    });

    function closeEmojiTray() {
        emojiTray.style.display = 'none';
        if(history.state && history.state.modal === 'emoji') history.back();
    }

    // =========================================
    //  15. STATUS & PRESENCE LOGIC (INSTANT)
    // =========================================
    
    function updateHeaderStatus() {
        // Privacy Guard 1: Their Settings
        if (chatTargetData && chatTargetData.showActivityStatus === false) {
             onlineDot.style.display = 'none';
             headerSubLabel.innerText = `@${chatTargetData.username}`;
             headerSubLabel.style.color = "var(--text-secondary)";
             return; 
        }

        // Privacy Guard 2: My Settings (Reciprocity)
        if (myUserData && myUserData.showActivityStatus === false) {
             onlineDot.style.display = 'none';
             headerSubLabel.innerText = `@${chatTargetData.username}`;
             headerSubLabel.style.color = "var(--text-secondary)";
             return;
        }

        if (!lastStatusData) return;
        
        if (lastStatusData.state === 'online') {
            onlineDot.style.display = 'block';
            headerSubLabel.innerText = "Active now";
            headerSubLabel.style.color = "#10b981"; // Green
            headerSubLabel.style.fontWeight = "600";
        } else {
            onlineDot.style.display = 'none';
            headerSubLabel.innerText = formatActiveTime(lastStatusData.last_changed);
            headerSubLabel.style.color = "var(--text-secondary)";
            headerSubLabel.style.fontWeight = "400";
        }
    }

    function monitorTargetStatus() {
        if (!targetUid) return;
        
        // Re-check privacy immediately
        if ((myUserData && myUserData.showActivityStatus === false) || 
            (chatTargetData && chatTargetData.showActivityStatus === false)) {
             onlineDot.style.display = 'none';
             headerSubLabel.innerText = `@${chatTargetData.username}`;
             return;
        }
        
        if (statusUpdateInterval) clearInterval(statusUpdateInterval);

        // Periodically refresh the text "5m ago" -> "6m ago"
        statusUpdateInterval = setInterval(() => {
            updateHeaderStatus();
        }, 60000);

        rdb.ref('/status/' + targetUid).on('value', (snapshot) => {
            lastStatusData = snapshot.val();
            
            // Clear pending typing logic if status updates
            if (statusTimeout) clearTimeout(statusTimeout);
            
            if (!lastStatusData) {
               headerSubLabel.innerText = `@${chatTargetData.username}`;
               return;
            }

            // NEW FIX: Smooth Opacity transition to avoid sudden harsh flicker 
            if(isFirstStatusLoad) {
                headerSubLabel.style.opacity = '0';
                setTimeout(() => headerSubLabel.style.opacity = '1', 150);
                isFirstStatusLoad = false;
            }

            // === INSTANT UPDATE LOGIC (CRITICAL FIX) ===
            // Directly calculate timeAgo here immediately, do not wait for next tick.
            updateHeaderStatus();
        });
    }

    // =========================================
    //  16. AUTH & INIT
    // =========================================
    auth.onAuthStateChanged(user => {
        if (user) { 
            myUid = user.uid; 
            localStorage.setItem('my_uid_cache', myUid);
            
            db.collection('users').doc(myUid).get().then(doc => {
                 if (doc.exists) {
                      myUserData = doc.data();
                      // Only start monitoring if privacy settings allow
                      if (targetUid) {
                          monitorTargetStatus();
                          checkBlockingStatus(); // NEW: Check Blocking
                      }
                 }
            });
            initChat(); 
        }
        else { window.location.href = 'login.html'; }
    });

    async function initChat() {
        if(!targetUsername) return;

        // Fetch Fresh User Data (Background)
        const snap = await db.collection("users").where("username", "==", targetUsername).get();
        if (snap.empty) return;
        
        targetUid = snap.docs[0].id;
        chatTargetData = snap.docs[0].data();
        chatTargetData.uid = targetUid; 
        
        // Update Cache
        localStorage.setItem(`chat_user_${targetUsername}`, JSON.stringify(chatTargetData));

        chatId = myUid < targetUid ? `${myUid}_${targetUid}` : `${targetUid}_${myUid}`;
        
        // Update Header UI
        const pfp = document.getElementById('h-pfp');
        pfp.classList.remove('loading-shimmer');
        const pfpUrl = chatTargetData.photoURL || 'https://via.placeholder.com/150';
        pfp.src = pfpUrl;
        typingPfp.src = pfpUrl;

        document.getElementById('h-display-name').innerText = chatTargetData.name || chatTargetData.username;
        if(chatTargetData.verified === true) {
            document.getElementById('v-badge').style.display = 'block';
        } else {
            document.getElementById('v-badge').style.display = 'none';
        }

        // Start Monitoring Status
        if(myUserData) monitorTargetStatus();
        
        // Run Blocking Check
        checkBlockingStatus();
        
        // Start Pulse Check
        checkPulseInvitation();

        // Mark as Seen
        db.collection("chats").doc(chatId).update({ 
            [`unreadCount.${myUid}`]: 0, 
            seen: true 
        }).then(() => {
            // INSTANT INBOX CACHE UPDATE FOR READ STATUS
            updateInboxCacheLocal(chatId, chatTargetData.lastMessage || "Message seen", chatTargetData.lastSender, false);
        }).catch(e => {});

        // Typing Listener (UPDATED FOR RECORDING)
        rdb.ref(`typing/${chatId}/${targetUid}`).on('value', (s) => {
            const val = s.val();
            const bubble = document.getElementById('typing-bubble-content');
            
            if (val === 'recording') {
                typingRow.style.display = 'flex';
                bubble.className = "rec-ind-bubble";
                bubble.innerHTML = `
                    <div class="rec-wave-icon"><div class="rec-wave-bar"></div><div class="rec-wave-bar"></div><div class="rec-wave-bar"></div></div>
                    Recording...
                `;
                inputBox.style.boxShadow = "0 0 15px rgba(255, 69, 58, 0.3)"; // NEW FEATURE: Glow red when recording
                scrollToBottom(true); /* MODIFIED: Glide when typing block shows */
            } else if (val === true) {
                typingRow.style.display = 'flex';
                bubble.className = "typing-bubble";
                bubble.innerHTML = '<div class="typing-dot"></div><div class="typing-dot"></div><div class="typing-dot"></div>';
                inputBox.style.boxShadow = "0 0 15px rgba(255, 109, 0, 0.3)"; // NEW FEATURE: Glow orange when typing
                scrollToBottom(true); /* MODIFIED: Glide when typing block shows */
            } else {
                typingRow.style.display = 'none';
                inputBox.style.boxShadow = "none"; // NEW FEATURE: Remove glow
            }
        });

        startListener(); 
        setupObserver();
        
        // REPLACED GLOBAL SLIDE WITH NEW LONG-PRESS TIMESTAMPS
        setupGlobalTimestamps(); 
    }
    
    // NEW: Check if blocked (by me or by them)
    function checkBlockingStatus() {
        if (!myUserData || !chatTargetData) return;

        // Check if I blocked them
        const amIBlocking = (myUserData.blocked || []).some(u => (typeof u === 'string' ? u : u.uid) === targetUid);
        
        // Check if they blocked me
        const isBlockedBy = (chatTargetData.blocked || []).some(u => (typeof u === 'string' ? u : u.uid) === myUid);

        if (amIBlocking || isBlockedBy) {
            document.querySelector('.input-area-container').style.display = 'none';
            document.getElementById('blocked-banner').style.display = 'block';
        } else {
            document.querySelector('.input-area-container').style.display = 'block';
            document.getElementById('blocked-banner').style.display = 'none';
        }
    }

    // NEW: Pulse Invitation Logic
    function checkPulseInvitation() {
        // We listen to the room document that matches our chatId (sorted UIDs)
        // because Pulse logic uses same sorted UIDs for 1-on-1 rooms
        const roomRef = db.collection('pulse_rooms').doc(chatId);
        
        pulseListener = roomRef.onSnapshot(doc => {
            if (doc.exists) {
                const data = doc.data();
                // Determine fields based on sort order
                const isUserA = myUid < targetUid;
                const otherField = isUserA ? 'userB' : 'userA';
                const myField = isUserA ? 'userA' : 'userB';
                
                // If they are online/waiting AND I am not in yet
                if ((data[otherField] === 'online' || data[otherField] === 'waiting') && 
                    (!data[myField] || data[myField] === 'offline')) {
                    
                    // Check Cooldown
                    const dismissedAt = localStorage.getItem('pulse_dismiss_' + targetUid);
                    if (dismissedAt) {
                        const diff = Date.now() - parseInt(dismissedAt);
                        // 1 hour = 3600000 ms
                        if (diff < 3600000) return; 
                    }
                    
                    // Show Banner
                    document.getElementById('pulse-invite-banner').style.display = 'flex';
                } else {
                    document.getElementById('pulse-invite-banner').style.display = 'none';
                }
            } else {
                document.getElementById('pulse-invite-banner').style.display = 'none';
            }
        });
    }

    window.dismissPulseInvite = function() {
        document.getElementById('pulse-invite-banner').style.display = 'none';
        // Set 1 hr cooldown
        localStorage.setItem('pulse_dismiss_' + targetUid, Date.now().toString());
    }

    window.joinPulseSession = function() {
        window.location.href = `pulse.html?user=${targetUsername}`;
    }

    // =========================================
    //  17. MESSAGE LISTENER & LIVE REACTION LOGIC
    // =========================================
    function startListener() {
        if (unsubscribe) unsubscribe();
        
        unsubscribe = db.collection("chats").doc(chatId).collection("messages")
            .orderBy("timestamp", "desc")
            .limit(20)
            .onSnapshot(snapshot => {
                if (snapshot.empty) return;
                
                if (!lastVisible) lastVisible = snapshot.docs[snapshot.docs.length - 1];
                let isNewIncoming = false;
                let hasVisualChanges = false;
                let reactionOnlyUpdates = false;

                snapshot.docChanges().forEach(change => {
                    const msgData = change.doc.data();
                    const msgId = change.doc.id;
                    msgData.id = msgId; 
                    
                    const existing = messagesMap.get(msgId);

                    if (change.type === "added") {
                        if(!existing) {
                            messagesMap.set(msgId, msgData);
                            if(msgData.sender !== myUid) {
                                isNewIncoming = true;
                                checkKeywords(msgData.text); // <--- ADDED: Trigger effects for receiver
                                
                                // INBOX INSTANT CACHE UPDATE FOR NEW MESSAGE
                                let displayTxt = msgData.text || "New message";
                                if(msgData.imageUrl) displayTxt = " Image";
                                else if(msgData.fileUrl) displayTxt = " Attachment";
                                updateInboxCacheLocal(chatId, displayTxt, msgData.sender, true);
                            }
                            hasVisualChanges = true;
                        } else {
                            // GLITCH FIX: If it exists in cache (instantRender), don't flag as visual change
                            // unless critical data is different. This prevents the wipe/flicker.
                            if(existing.text !== msgData.text || 
                               (existing.reactions && !msgData.reactions) || 
                               (!existing.reactions && msgData.reactions) ||
                               JSON.stringify(existing.reactions) !== JSON.stringify(msgData.reactions) ||
                               existing.seen !== msgData.seen) {
                                hasVisualChanges = true;
                            }
                            // Always update the map to ensure we have the live objects (Timestamp vs ISO)
                            messagesMap.set(msgId, msgData);
                        }
                    } 
                    else if (change.type === "modified") {
                        // === DETECT NEW REACTIONS HERE AND TRIGGER PHYSICS ===
                        const oldData = messagesMap.get(msgId);
                        
                        // Physics trigger: Fire floating emoji
                        detectNewReactions(oldData, msgData, msgId);
                        
                        // GLITCH FIX: If ONLY reactions changed, perform a DOM surgical update
                        // instead of flagging hasVisualChanges which wipes the list.
                        const oldReactionsStr = JSON.stringify(oldData ? oldData.reactions : {});
                        const newReactionsStr = JSON.stringify(msgData.reactions || {});
                        
                        if(oldData && oldData.text === msgData.text && oldReactionsStr !== newReactionsStr) {
                            // It's a reaction-only update. 
                            // 1. Update Map
                            messagesMap.set(msgId, msgData);
                            // 2. Surgical DOM update
                            updateReactionDOM(msgId, msgData.reactions);
                            // 3. Ensure we DO NOT re-render all
                            // hasVisualChanges remains false for this loop
                        } else {
                            // Text changed or something major, do full re-render
                            messagesMap.set(msgId, msgData);
                            hasVisualChanges = true;
                        }
                    } 
                    else if (change.type === "removed") {
                        messagesMap.delete(msgId);
                        // Fix for immediate removal from UI
                        const el = document.getElementById(msgId);
                        if(el) el.remove();
                        // Also force re-render to fix group styling if needed, but simple removal works for speed
                        hasVisualChanges = true; 
                    }
                    
                    // Mark read logic
                    if(msgData.sender !== myUid && !msgData.seen) {
                        db.collection("chats").doc(chatId).collection("messages").doc(msgId).update({ 
                            seen: true,
                            seenAt: firebase.firestore.FieldValue.serverTimestamp() 
                        });
                        // INBOX CACHE UPDATE FOR READ STATUS (BACKGROUND)
                        updateInboxCacheLocal(chatId, msgData.text || "Message", msgData.sender, false);
                    }
                });

                if(isNewIncoming) { 
                    vibrate(20);
                    if(chatFlow.scrollHeight - chatFlow.scrollTop - chatFlow.clientHeight > 250) {
                        scrollBtn.classList.add('new-msg');
                    }
                }

                if (hasVisualChanges || isFirstLoad) {
                    if (isFirstLoad) {
                        renderAll();
                        chatFlow.scrollTop = chatFlow.scrollHeight;
                        setTimeout(() => {
                            chatFlow.style.opacity = '1';
                            isFirstLoad = false;
                        }, 50);
                    } else {
                        const isNearBottom = chatFlow.scrollHeight - chatFlow.scrollTop - chatFlow.clientHeight < 300;
                        renderAll();
                        // NEW FIX: Smarter auto-scroll. Only scroll if near bottom, or if it was MY message. 
                        // Prevents random jumping when reading older messages and a new one arrives.
                        if (isNearBottom || (!isNewIncoming)) {
                            requestAnimationFrame(() => scrollToBottom(isNewIncoming)); /* MODIFIED: Glide in */
                        }
                    }
                }
                
                saveMessagesToCache();
            });
    }

    // NEW FUNCTION: Surgical DOM update for reactions (prevents glitching)
    function updateReactionDOM(msgId, reactions) {
        const bubble = document.getElementById(`bubble-${msgId}`) || document.getElementById(`media-${msgId}`);
        // Find reaction badges in this row (text bubble or media wrapper)
        // We look for ID react-{msgId}
        const badgeElements = document.querySelectorAll(`#react-${msgId}`);
        
        let reactionsList = [];
        if (reactions) reactionsList = Object.values(reactions);
        const reactionDisplay = reactionsList.map(r => r.emoji).join(' ');
        
        badgeElements.forEach(el => {
            // Only update DOM if the text is actually different (prevents loop glitch)
            if (el.innerText !== reactionDisplay) {
                el.innerText = reactionDisplay;
                el.style.display = reactionDisplay ? 'block' : 'none';
                
                // Add a small bounce animation ONLY if visible
                if (reactionDisplay) {
                    el.classList.remove('updated');
                    void el.offsetWidth; // Trigger reflow
                    el.classList.add('updated');
                }
            }
        });
    }

    // NEW FUNCTION: Detects if someone else added a reaction and triggers physics
    function detectNewReactions(oldData, newData, msgId) {
        if (!oldData || !newData) return;
        
        const oldReactions = oldData.reactions || {};
        const newReactions = newData.reactions || {};
        
        // Iterate through new reactions to find added ones
        Object.keys(newReactions).forEach(uid => {
            const oldReaction = oldReactions[uid];
            const newReaction = newReactions[uid];
            
            // If there was no reaction before, or the emoji changed
            if (!oldReaction || oldReaction.emoji !== newReaction.emoji) {
                // Trigger Visual Pop for BOTH users (Sender sees it locally via click, receiver sees it here)
                // We add a slight delay if it's the sender to avoid conflict with local click anim
                if (uid !== myUid) {
                    triggerReactionPop(msgId, newReaction.emoji);
                    if(newReaction.emoji === '') triggerHeartAnimation(); // <--- ADDED: Trigger full screen heart for receiver
                }
            }
        });
    }

    // NEW FUNCTION: Spawns a floating emoji
    function triggerReactionPop(msgId, emoji) {
        // Try to find the bubble or the media container
        const bubble = document.getElementById(`bubble-${msgId}`) || 
                       document.getElementById(msgId)?.querySelector('.msg-media-wrapper') ||
                       document.getElementById(msgId)?.querySelector('.msg-video-container');
                       
        if (!bubble) return;

        const rect = bubble.getBoundingClientRect();
        
        // Calculate start position (center of bubble roughly)
        const startX = rect.left + (rect.width / 2) - 20; // 20 is half emoji width
        const startY = rect.top + (rect.height / 2);

        const floatEl = document.createElement('div');
        floatEl.className = 'floating-emoji';
        floatEl.innerText = emoji;
        floatEl.style.left = `${startX}px`;
        floatEl.style.top = `${startY}px`;
        
        document.body.appendChild(floatEl);
        
        // Play sound if desired
        likeSound.play().catch(()=>{});

        // Remove from DOM after animation
        setTimeout(() => {
            floatEl.remove();
        }, 1500);
    }

    function saveMessagesToCache() {
        if (!chatId) return;
        try {
            const msgsToSave = Array.from(messagesMap.values()).map(m => {
                let savedM = { ...m };
                if (m.timestamp && typeof m.timestamp.toDate === 'function') {
                    savedM.timestampIso = m.timestamp.toDate().toISOString();
                }
                if (m.seenAt && typeof m.seenAt.toDate === 'function') {
                    savedM.seenAtIso = m.seenAt.toDate().toISOString();
                }
                delete savedM.timestamp; 
                delete savedM.seenAt;
                return savedM;
            });
            msgsToSave.sort((a, b) => new Date(a.timestampIso) - new Date(b.timestampIso));
            const limitMsgs = msgsToSave.slice(-50); 
            localStorage.setItem(`chat_msgs_${chatId}`, JSON.stringify(limitMsgs));
        } catch (e) { console.error("Cache Save Error", e); }
    }

    function renderAll() {
        /*
        ========================================================================================
        ORIGINAL RENDER LOOP PRESERVED IN COMMENTS (DO NOT REMOVE LINES REQUIREMENT)
        ========================================================================================
        container.innerHTML = '';
        const sorted = Array.from(messagesMap.entries())
            .filter(([id, data]) => data.timestamp) 
            .sort((a, b) => {
                const tA = (data => data.timestamp.toMillis ? data.timestamp.toMillis() : new Date(data.timestampIso).getTime());
                const tB = (data => data.timestamp.toMillis ? data.timestamp.toMillis() : new Date(data.timestampIso).getTime());
                return tA(a[1]) - tB(b[1]);
            });

        let lastDateLabel = "";
        let lastSeenMsgId = null;
        let lastMsgTime = 0;

        for (let i = sorted.length - 1; i >= 0; i--) {
            const [id, data] = sorted[i];
            if (data.sender === myUid && data.seen === true) {
                lastSeenMsgId = id;
                break; 
            }
        }
        
        sorted.forEach(([id, data], index) => { 
            const msgDate = data.timestamp.toDate ? data.timestamp.toDate() : new Date(data.timestampIso);
            const msgTime = msgDate.getTime();
            
            const dateLabel = getDateDivider(msgDate);
            if (dateLabel !== lastDateLabel) {
                const div = document.createElement('div');
                div.className = "date-divider";
                div.innerText = dateLabel;
                container.appendChild(div);
                lastDateLabel = dateLabel;
                lastMsgTime = msgTime;
            } else {
                if (lastMsgTime > 0 && (msgTime - lastMsgTime) > 3600000) {
                    const tDiv = document.createElement('div');
                    tDiv.className = "time-divider";
                    tDiv.innerText = formatTime12(msgDate);
                    container.appendChild(tDiv);
                }
            }
            
            lastMsgTime = msgTime; 

            const prevMsg = index > 0 ? sorted[index - 1][1] : null;
            const nextMsg = index + 1 < sorted.length ? sorted[index + 1][1] : null;

            const isFirstInGroup = !prevMsg || prevMsg.sender !== data.sender || (msgDate - (prevMsg.timestamp.toDate ? prevMsg.timestamp.toDate() : new Date(prevMsg.timestampIso))) > 300000;
            const isLastInGroup = !nextMsg || nextMsg.sender !== data.sender || ((nextMsg.timestamp.toDate ? nextMsg.timestamp.toDate() : new Date(nextMsg.timestampIso)) - msgDate) > 300000;

            renderMessage(data, id, id === lastSeenMsgId, isFirstInGroup, isLastInGroup); 
        });
        ========================================================================================
        */

        // ========================================================================================
        // NEW SMART VIRTUAL DOM DIFFING (Fixes "Render all messages every time" and flickering)
        // ========================================================================================
        let tempContainer = document.createElement('div');
        let originalContainer = container;
        container = tempContainer; // Hijack DOM target so renderMessage goes to Temp

        const sorted = Array.from(messagesMap.entries())
            .filter(([id, data]) => data.timestamp)
            .sort((a, b) => {
                const tA = (data => data.timestamp.toMillis ? data.timestamp.toMillis() : new Date(data.timestampIso).getTime());
                const tB = (data => data.timestamp.toMillis ? data.timestamp.toMillis() : new Date(data.timestampIso).getTime());
                return tA(a[1]) - tB(b[1]);
            });

        let lastDateLabel = "";
        let lastSeenMsgId = null;
        let lastMsgTime = 0;

        for (let i = sorted.length - 1; i >= 0; i--) {
            const [id, data] = sorted[i];
            if (data.sender === myUid && data.seen === true) {
                lastSeenMsgId = id;
                break;
            }
        }

        sorted.forEach(([id, data], index) => {
            const msgDate = data.timestamp.toDate ? data.timestamp.toDate() : new Date(data.timestampIso);
            const msgTime = msgDate.getTime();

            const dateLabel = getDateDivider(msgDate);
            if (dateLabel !== lastDateLabel) {
                const div = document.createElement('div');
                div.className = "date-divider";
                div.innerText = dateLabel;
                container.appendChild(div);
                lastDateLabel = dateLabel;
                lastMsgTime = msgTime;
            } else {
                if (lastMsgTime > 0 && (msgTime - lastMsgTime) > 3600000) {
                    const tDiv = document.createElement('div');
                    tDiv.className = "time-divider";
                    tDiv.innerText = formatTime12(msgDate);
                    container.appendChild(tDiv);
                }
            }

            lastMsgTime = msgTime;

            const prevMsg = index > 0 ? sorted[index - 1][1] : null;
            const nextMsg = index + 1 < sorted.length ? sorted[index + 1][1] : null;

            const isFirstInGroup = !prevMsg || prevMsg.sender !== data.sender || (msgDate - (prevMsg.timestamp.toDate ? prevMsg.timestamp.toDate() : new Date(prevMsg.timestampIso))) > 300000;
            const isLastInGroup = !nextMsg || nextMsg.sender !== data.sender || ((nextMsg.timestamp.toDate ? nextMsg.timestamp.toDate() : new Date(nextMsg.timestampIso)) - msgDate) > 300000;

            renderMessage(data, id, id === lastSeenMsgId, isFirstInGroup, isLastInGroup);
        });

        // Restore original container reference
        container = originalContainer;

        // Perform DOM Diff
        if (container.children.length === 0) {
            // First load: just dump everything in
            while (tempContainer.firstChild) container.appendChild(tempContainer.firstChild);
        } else {
            let newChildren = Array.from(tempContainer.children);
            let oldChildren = Array.from(container.children);

            for (let i = 0; i < newChildren.length; i++) {
                let newChild = newChildren[i];
                let oldChild = oldChildren[i];

                if (!oldChild) {
                    // It's a brand new appended message
                    container.appendChild(newChild);
                } else if (newChild.id && oldChild.id === newChild.id) {
                    // The IDs match. Only update if the content or classes actually changed
                    if (oldChild.innerHTML !== newChild.innerHTML || oldChild.className !== newChild.className) {
                        let audio = oldChild.querySelector('audio');
                        // Never interrupt playing audio!
                        if (audio && !audio.paused) {
                            // Do nothing, let audio finish
                        } else {
                            oldChild.innerHTML = newChild.innerHTML;
                            oldChild.className = newChild.className;
                            
                            // Reattach Listeners for the updated node
                            let msgData = messagesMap.get(newChild.id);
                            let bubbleEl = oldChild.querySelector(`#bubble-${newChild.id}`);
                            if(bubbleEl && bubbleEl.style.display !== 'none') attachMessageListeners(bubbleEl, newChild.id, msgData);
                            
                            let mediaEl = oldChild.querySelector('.msg-media-wrapper') || oldChild.querySelector('.msg-video-container');
                            if(mediaEl) attachMessageListeners(mediaEl, newChild.id, msgData);
                            
                            let pill = oldChild.querySelector('.msg-audio-pill') || oldChild.querySelector('.msg-file-pill');
                            if(pill) attachMessageListeners(pill, newChild.id, msgData);
                        }
                    }
                } else {
                    // Fallback for mismatch (e.g. dividers adjusting)
                    container.replaceChild(newChild, oldChild);
                }
            }
            // Remove any trailing messages that got deleted from DB
            while (container.children.length > newChildren.length) {
                container.removeChild(container.lastChild);
            }
        }
        // ========================================================================================
    }

    function renderMessage(m, id, isLastSeen, isFirstInGroup, isLastInGroup) {
        const side = m.sender === myUid ? 'sent' : 'received';
        const date = m.timestamp.toDate ? m.timestamp.toDate() : new Date(m.timestampIso);

        const rowDiv = document.createElement('div');
        rowDiv.id = id;
        
        let rowClass = `msg-row ${side}`;
        if(isLastInGroup) rowClass += ' group-bottom';
        if(isFirstInGroup && isLastInGroup) rowClass += ' single';
        rowDiv.className = rowClass;
        
        let reactionsList = [];
        let myReaction = null;
        if (m.reactions) {
            reactionsList = Object.values(m.reactions);
            if (m.reactions[myUid]) myReaction = m.reactions[myUid].emoji;
        }
        const reactionDisplay = reactionsList.map(r => r.emoji).join(' ');

        let seenText = "";
        if (isLastSeen && side === 'sent') {
            if (m.seenAt) {
                const sDate = m.seenAt.toDate ? m.seenAt.toDate() : new Date(m.seenAtIso);
                seenText = "Seen " + timeAgo(sDate);
            } else {
                seenText = "Seen"; 
            }
        }
        
        // Styling Vars
        const boxStyle = reactionDisplay ? 'style="margin-bottom: 16px"' : '';
        const replyHtml = m.replyTo ? `<div class="reply-box-ui" onclick="event.stopPropagation(); scrollToAndFlash('${m.replyTo}')"> ${m.replyTo}</div>` : '';

        // Note Reply - FULL UI RENDER (Updated Layout)
        const noteMeta = m.noteMetadata || {};
        const noteReplyHtml = m.replyToNote ? `
            <div class="note-reply-wrapper">
                <div class="note-reply-pill ${noteMeta.isGlass ? 'glass' : ''}" style="
                    background: ${noteMeta.bgTexture ? `url(${noteMeta.bgTexture})` : (noteMeta.bgColor || '#262626')};
                    background-size: cover;
                    color: ${noteMeta.textColor || '#fff'};
                    font-family: ${noteMeta.font || 'system-ui'};
                ">
                    <div style="display:flex;align-items:center;gap:6px;margin-bottom:8px; width:100%; justify-content:center; opacity:0.9;">
                        <img src="${noteMeta.pfp || (chatTargetData ? chatTargetData.photoURL : 'https://via.placeholder.com/20')}" style="width:24px;height:24px;border-radius:50%;border:2px solid rgba(255,255,255,0.2);">
                        <span style="font-size:0.75rem;font-weight:700; text-shadow:0 1px 4px rgba(0,0,0,0.5);">${noteMeta.username || 'User'}</span>
                    </div>
                    
                    ${noteMeta.songName ? `
                    <div class="note-music-pill">
                         <span class="material-icons-round" style="font-size:10px;">music_note</span>
                         <span style="max-width:80px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${noteMeta.songName}</span>
                    </div>` : ''}

                    <div style="font-size:1rem;font-weight:700;line-height:1.3; text-shadow:0 1px 5px rgba(0,0,0,0.4); padding: 0 5px;">
                        ${m.replyToNote}
                    </div>
                </div>
                <div class="note-connector"></div>
            </div>` : '';
        
        // Group Logic for Borders
        let groupClass = '';
        if (isFirstInGroup && isLastInGroup) groupClass = 'single';
        else if (isFirstInGroup) groupClass = 'group-top';
        else if (isLastInGroup) groupClass = 'group-bottom';
        else groupClass = 'group-mid';

        let mediaHtml = '';
        let bubbleClass = `bubble ${groupClass}`;
        let bubbleStyle = '';

        // Media Types Construction
        if (m.imageUrl) {
            mediaHtml = `
            <div class="msg-media-wrapper ${groupClass}" onclick="document.getElementById('media-viewer').open('${m.imageUrl}')">
                <img src="${m.imageUrl}" class="chat-media-img">
                <div id="react-${id}" class="reaction-badge" onclick="showReactionDetails('${id}', event)" style="${reactionDisplay ? 'display:block' : ''}">${reactionDisplay}</div>
            </div>`;
            bubbleClass = `bubble has-media ${groupClass}`;
            if(!m.text) bubbleStyle = "display:none;";
        } 
        else if (m.fileUrl && m.fileMeta && m.fileMeta.type.includes('video')) {
            mediaHtml = `
            <div class="msg-video-container" onclick="document.getElementById('media-viewer').open('${m.fileUrl}', 'video')">
                <video src="${m.fileUrl}#t=0.5" class="chat-media-img" style="object-fit:cover; width:100%; height:220px; background:#000;" preload="metadata"></video>
                <div class="play-overlay"><span class="material-icons-round" style="font-size:32px; color:white;">play_arrow</span></div>
                <div id="react-${id}" class="reaction-badge" onclick="showReactionDetails('${id}', event)" style="${reactionDisplay ? 'display:block' : ''}">${reactionDisplay}</div>
            </div>`;
            bubbleClass = `bubble has-media ${groupClass}`;
            if(!m.text) bubbleStyle = "display:none;";
        }
        else if (m.fileUrl && m.fileMeta && m.fileMeta.type.includes('audio')) {
            const safeId = 'audio-' + id;
            // VOICE NOTE UI WITH SPEED - BIGGER UI
            mediaHtml = `
            <div class="msg-audio-pill" id="pill-${safeId}">
                <div class="audio-control-btn" onclick="event.stopPropagation(); window.toggleAudio('${safeId}');">
                    <svg id="icon-${safeId}" viewBox="0 0 24 24" style="pointer-events: none;"><path d="M8 5v14l11-7z"/></svg>
                </div>
                <div class="audio-wave-container" id="wave-${safeId}">
                    <div class="wave-bar"></div><div class="wave-bar"></div><div class="wave-bar"></div>
                    <div class="wave-bar"></div><div class="wave-bar"></div><div class="wave-bar"></div>
                    <div class="wave-bar"></div><div class="wave-bar"></div><div class="wave-bar"></div>
                    <div class="wave-bar"></div><div class="wave-bar"></div><div class="wave-bar"></div>
                    <div class="wave-bar"></div><div class="wave-bar"></div><div class="wave-bar"></div>
                </div>
                <div class="audio-speed-btn" id="speed-${safeId}" onclick="event.stopPropagation(); changePlaybackRate('${safeId}')">1x</div>
                
                <audio id="${safeId}" src="${m.fileUrl}" ontimeupdate="updateAudioUI('${safeId}')" onended="resetAudioUI('${safeId}')"></audio>
                
                <div id="react-${id}" class="reaction-badge" style="position:absolute; bottom:-8px; right:10px; ${reactionDisplay ? 'display:block' : ''}" onclick="showReactionDetails('${id}', event)">${reactionDisplay}</div>
            </div>`;
            bubbleClass = `bubble has-media ${groupClass}`; 
            if(!m.text) bubbleStyle = "display:none;";
        }
        else if (m.fileUrl) {
            mediaHtml = `
            <div class="msg-file-pill" onclick="window.open('${m.fileUrl}', '_blank')">
                <div class="file-icon"></div>
                <div class="file-details">
                    <div class="file-name">${m.fileMeta.name || "File"}</div>
                    <div class="file-meta">${(m.fileMeta.size / (1024*1024)).toFixed(2)} MB  ${m.fileMeta.type.toUpperCase()}</div>
                </div>
                <div id="react-${id}" class="reaction-badge" style="right:0; ${reactionDisplay ? 'display:block' : ''}" onclick="showReactionDetails('${id}', event)">${reactionDisplay}</div>
            </div>`;
            bubbleClass = `bubble has-media ${groupClass}`;
            if(!m.text) bubbleStyle = "display:none;";
        }

        const safeText = linkify(m.text);
        
        // --- ADDED: Swipe Reply Icon & Timestamp Footer ---
        let contentHTML = `
            <div class="swipe-reply-icon"><svg viewBox="0 0 24 24"><path d="M10 9V5l-7 7 7 7v-4.1c5 0 8.5 1.6 11 5.1-1-5-4-10-11-11z"/></svg></div>
            ${noteReplyHtml}
            ${replyHtml}
            ${mediaHtml}
            <div class="${bubbleClass}" id="bubble-${id}" style="${bubbleStyle}">
                <span id="text-${id}">${safeText} ${m.edited ? '<small style="opacity:0.6;font-size:0.65rem; margin-left:4px;">(edited)</small>' : ''}</span>
                ${(!m.imageUrl && !m.fileUrl && !m.fileMeta?.type?.includes('audio')) ? `<div id="react-${id}" class="reaction-badge" onclick="showReactionDetails('${id}', event)" style="${reactionDisplay ? 'display:block' : ''}">${reactionDisplay}</div>` : ''}
            </div>
            <div class="msg-timestamp-footer">${formatTime12(date)}</div>
        `;

        if (side === 'received') {
            const pfpUrl = chatTargetData ? chatTargetData.photoURL : 'https://via.placeholder.com/30';
            const pfpClass = isLastInGroup ? 'msg-avatar visible' : 'msg-avatar';
            
            rowDiv.innerHTML = `
                <div class="received-inner-row">
                    <img src="${pfpUrl}" class="${pfpClass}">
                    <div class="msg-bubble-box" ${boxStyle}>
                        ${contentHTML}
                    </div>
                </div>
                ${seenText ? `<div class="seen-status">${seenText}</div>` : ''}
            `;
        } else {
            rowDiv.innerHTML = `
                <div class="msg-bubble-box" ${boxStyle}>
                    ${contentHTML}
                </div>
                ${seenText ? `<div class="seen-status">${seenText}</div>` : ''}
            `;
        }
        
        // This append gets caught and managed by the Virtual DOM diff if called inside renderAll
        container.appendChild(rowDiv);
        
        // Attach Listeners
        const bubbleEl = rowDiv.querySelector(`#bubble-${id}`);
        if(bubbleEl && bubbleEl.style.display !== 'none') attachMessageListeners(bubbleEl, id, m);
        
        const mediaEl = rowDiv.querySelector('.msg-media-wrapper') || rowDiv.querySelector('.msg-video-container');
        if(mediaEl) attachMessageListeners(mediaEl, id, m);
        
        const pill = rowDiv.querySelector('.msg-audio-pill') || rowDiv.querySelector('.msg-file-pill');
        if(pill) attachMessageListeners(pill, id, m);
    }
    
    // =========================================
    //  18. INTERACTIONS & HELPERS
    // =========================================
    
    // --- 1. GLOBAL LONG PRESS FOR TIMESTAMPS ---
    function setupGlobalTimestamps() {
        const bg = document.getElementById('chat-flow');
        let pressTimer;
        
        bg.addEventListener('touchstart', (e) => {
            // Check if user is clicking on interactive elements or bubbles
            const isInteractive = e.target.closest('.msg-bubble-box') || 
                                  e.target.closest('.input-area-container') || 
                                  e.target.closest('#chat-header');
                                  
            if(!isInteractive) {
                pressTimer = setTimeout(() => {
                    const containerObj = document.getElementById('messages-container');
                    const chatFlow = document.getElementById('chat-flow');
                    
                    // FIXED: Calculate current scroll offset from bottom
                    const scrollBottomOffset = chatFlow.scrollHeight - chatFlow.scrollTop - chatFlow.clientHeight;
                    
                    // Apply class
                    containerObj.classList.add('show-timestamps');
                    
                    // FIXED: If user was near bottom, snap back to bottom instantly (prevent jump)
                    if(scrollBottomOffset < 50) {
                         chatFlow.scrollTop = chatFlow.scrollHeight;
                    }
                    
                    vibrate([50, 50]); // Vibrate twice
                }, 500);
            }
        }, {passive: true});

        bg.addEventListener('touchend', () => {
            clearTimeout(pressTimer);
            document.getElementById('messages-container').classList.remove('show-timestamps');
        });
        
        bg.addEventListener('touchmove', () => {
            clearTimeout(pressTimer); // Cancel if scrolling
        }, {passive: true});
    }
    
    // --- 2. SWIPE TO REPLY (BIDIRECTIONAL) ---
    function attachMessageListeners(element, id, m) {
            let reactionsList = [];
            let myReaction = null;
            if (m.reactions && m.reactions[myUid]) myReaction = m.reactions[myUid].emoji;

            // Double Tap to Like or Edit
            element.addEventListener('dblclick', (e) => {
                e.preventDefault(); e.stopPropagation(); 
                if (m.sender === myUid) {
                    // NEW FEATURE: Double tap own message to quick-edit
                    vibrate(40);
                    activeMenuId = id; 
                    initEdit();
                } else {
                    vibrate(50); 
                    triggerHeartAnimation();
                    applyReactionToId(id, myReaction === '' ? '' : '');
                }
            });

            // Long Press Menu & Swipe Logic
            let startX = 0, currentX = 0, menuTimer = null, isScrolling = false;
            let swipeBubbleBox = element.closest('.msg-bubble-box'); // We animate the wrapper
            let swipeIcon = swipeBubbleBox.querySelector('.swipe-reply-icon');
            let side = m.sender === myUid ? 'sent' : 'received';

            element.addEventListener('touchstart', (e) => {
                // FIX: Don't trigger swipe/menu if hitting audio controls
                if (e.target.closest('.audio-control-btn') || e.target.closest('.audio-speed-btn') || e.target.tagName === 'AUDIO') return;

                startX = e.touches[0].clientX;
                currentX = startX; // FIX: Initialize currentX to startX. Critical for long press detection without movement.
                isScrolling = false; 
                
                menuTimer = setTimeout(() => {
                    if (!isScrolling && Math.abs(currentX - startX) < 10) { 
                        vibrate(70); 
                        openMenu(id, m.sender, m.text); 
                    }
                }, 500);
            }, {passive: true});

            element.addEventListener('touchmove', (e) => {
                if (e.target.closest('.audio-control-btn') || e.target.closest('.audio-speed-btn')) return;

                currentX = e.touches[0].clientX;
                let diff = currentX - startX;
                
                // Detect scroll vs swipe
                if (Math.abs(diff) > 10) { 
                      clearTimeout(menuTimer);
                      isScrolling = true;
                }
                
                // Logic: 
                // Received (Left) -> Swipe Right (diff > 0)
                // Sent (Right) -> Swipe Left (diff < 0)
                
                if (side === 'received' && diff > 0 && diff < 150) {
                    swipeBubbleBox.style.transform = `translateX(${diff}px)`;
                    if(swipeIcon) {
                        let scale = Math.min(1, diff / 60);
                        swipeIcon.style.transform = `translateY(-50%) scale(${scale})`;
                    }
                } 
                else if (side === 'sent' && diff < 0 && diff > -150) {
                    swipeBubbleBox.style.transform = `translateX(${diff}px)`;
                    if(swipeIcon) {
                        let scale = Math.min(1, Math.abs(diff) / 60);
                        swipeIcon.style.transform = `translateY(-50%) scale(${scale})`;
                    }
                }
                
            }, {passive: true});

            element.addEventListener('touchend', (e) => {
                clearTimeout(menuTimer);
                if (e.target.closest('.audio-control-btn') || e.target.closest('.audio-speed-btn')) return;
                
                let diff = currentX - startX;
                let threshold = 60;
                let triggered = false;

                if (side === 'received' && diff > threshold) triggered = true;
                if (side === 'sent' && diff < -threshold) triggered = true;

                if (triggered && isScrolling) {
                    vibrate(40);
                    let replyText = m.text;
                    if(!replyText) {
                        if(m.imageUrl) replyText = " Photo";
                        else if(m.fileMeta && m.fileMeta.type.includes('audio')) replyText = " Audio";
                        else replyText = "Attachment";
                    }
                    mInput.focus(); // NEW FIX: Force focus directly inside the synchronous touchend execution path before timeouts
                    triggerReply(replyText);
                }

                // Animate Back
                swipeBubbleBox.style.transition = "transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275)";
                swipeBubbleBox.style.transform = `translateX(0px)`;
                if(swipeIcon) {
                    swipeIcon.style.transition = "transform 0.2s";
                    swipeIcon.style.transform = `translateY(-50%) scale(0)`;
                }
                
                setTimeout(() => { 
                    swipeBubbleBox.style.transition = ""; 
                    if(swipeIcon) swipeIcon.style.transition = "";
                }, 200);
                
                startX = 0; currentX = 0; isScrolling = false;
            });
    }

    // Audio Player Logic with Speed
    window.toggleAudio = function(id) {
        console.log("Toggle audio called for ID:", id);
        const audio = document.getElementById(id);
        const icon = document.getElementById('icon-' + id);
        const wave = document.getElementById('wave-' + id);
        
        if (!audio) {
            console.error("Audio element not found:", id);
            return;
        }
        
        // Stop all other audio
        document.querySelectorAll('audio').forEach(a => {
            if(a.id !== id) { a.pause(); resetAudioUI(a.id); }
        });

        if (audio.paused) {
            var playPromise = audio.play();
            if (playPromise !== undefined) {
                playPromise.then(_ => {
                      // Play started
                      console.log("Playing audio");
                      icon.innerHTML = '<path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>'; // Pause
                      if(wave) wave.classList.add('audio-playing');
                }).catch(error => {
                      console.error("Auto-play was prevented", error);
                });
            }
        } else {
            audio.pause();
            console.log("Paused audio");
            icon.innerHTML = '<path d="M8 5v14l11-7z"/>'; // Play
            if(wave) wave.classList.remove('audio-playing');
        }
    };
    
    window.changePlaybackRate = function(id) {
        const audio = document.getElementById(id);
        const btn = document.getElementById('speed-' + id);
        if(!audio) return;
        
        let current = audio.playbackRate;
        let next = 1.0;
        if(current === 1.0) next = 1.5;
        else if(current === 1.5) next = 2.0;
        else next = 1.0;
        
        audio.playbackRate = next;
        btn.innerText = next + "x";
        // event propagation already stopped inline
    }

    window.updateAudioUI = function(id) {}; // Visualizer handles animation via CSS class
    window.resetAudioUI = function(id) {
        const icon = document.getElementById('icon-' + id);
        const wave = document.getElementById('wave-' + id);
        const audio = document.getElementById(id);
        const speedBtn = document.getElementById('speed-' + id); // FIX: Get element safely

        if(icon) icon.innerHTML = '<path d="M8 5v14l11-7z"/>';
        if(wave) wave.classList.remove('audio-playing');
        if(audio) { 
            audio.playbackRate = 1.0; 
            // FIX: Check if speedBtn exists before setting innerText
            if(speedBtn) speedBtn.innerText = "1x"; 
        }
    };

    // Helper Functions
    function timeAgo(date) {
        const seconds = Math.floor((new Date() - date) / 1000);
        let interval = seconds / 31536000;
        if (interval > 1) return Math.floor(interval) + "y";
        interval = seconds / 2592000;
        if (interval > 1) return Math.floor(interval) + "mo";
        interval = seconds / 86400;
        if (interval > 1) return Math.floor(interval) + "d";
        interval = seconds / 3600;
        if (interval > 1) return Math.floor(interval) + "h";
        interval = seconds / 60;
        if (interval > 1) return Math.floor(interval) + "m";
        return "Now";
    }

    function formatActiveTime(timestamp) {
        if (!timestamp) return "";
        const now = Date.now();
        const diff = now - timestamp;
        if (diff < 60000) return "Active now";
        return "Active " + timeAgo(new Date(timestamp)) + " ago";
    }

    // FIXED: Robust time formatting
    function formatTime12(date) {
        if(!date || isNaN(date.getTime())) return "";
        let hours = date.getHours();
        let minutes = date.getMinutes();
        let ampm = hours >= 12 ? 'PM' : 'AM';
        hours = hours % 12;
        hours = hours ? hours : 12;
        minutes = minutes < 10 ? '0'+minutes : minutes;
        return `${hours}:${minutes} ${ampm}`;
    }

    function getDateDivider(date) {
        const today = new Date();
        const yesterday = new Date();
        yesterday.setDate(today.getDate() - 1);
        if (date.toDateString() === today.toDateString()) return "Today";
        if (date.toDateString() === yesterday.toDateString()) return "Yesterday";
        return date.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
    }

    function triggerHeartAnimation() {
        const h = document.getElementById('heart-overlay');
        h.style.animation = 'none';
        h.offsetHeight; 
        h.style.animation = 'heartPop 0.8s ease-out';
        likeSound.play().catch(e => {}); 
        
        // MODIFICATION: Removed full-screen fireEffect('hearts') here so only the overlay pops
        // fireEffect('hearts'); 
    }

    // === NEW IMPROVED EFFECT SYSTEM (CONFETTI / HEARTS) ===
    function fireEffect(type) {
        const canvas = document.getElementById('effect-canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        let particles = [];
        
        // Configuration per type
        const particleCount = type === 'hearts' ? 40 : 150; 
        const colors = type === 'hearts' 
            ? ['#FF0000', '#FF1493', '#FF69B4', '#FFB6C1', '#FFFFFF'] 
            : ['#FFD700', '#FF4500', '#00BFFF', '#32CD32', '#FF69B4', '#9400D3'];

        // Initialize particles
        for(let i=0; i < particleCount; i++) {
            particles.push({
                x: Math.random() * canvas.width,
                y: type === 'hearts' ? canvas.height + Math.random() * 200 : -Math.random() * 200, // Hearts start bottom, Confetti top
                size: Math.random() * (type === 'hearts' ? 15 : 8) + 5,
                
                // Physics
                speedY: type === 'hearts' ? -(Math.random() * 3 + 2) : (Math.random() * 5 + 3), // Hearts go up (-), Confetti goes down (+)
                speedX: Math.random() * 2 - 1, // Horizontal drift
                
                // Rotation/Flutter
                rotation: Math.random() * 360,
                rotationSpeed: Math.random() * 10 - 5,
                tilt: Math.random() * 10,
                tiltAngle: Math.random() * Math.PI,
                tiltAngleIncrement: Math.random() * 0.05 + 0.02,
                
                // Visuals
                color: colors[Math.floor(Math.random() * colors.length)],
                opacity: 1,
                wobble: Math.random() * 10,
                wobbleIncrement: Math.random() * 0.03 + 0.01
            });
        }
        
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            let active = false;
            
            particles.forEach((p) => {
                // Update position
                p.wobble += p.wobbleIncrement;
                p.x += Math.sin(p.wobble); // Sway side to side
                p.y += p.speedY;
                p.tiltAngle += p.tiltAngleIncrement;
                p.tilt = Math.sin(p.tiltAngle) * 15; // 3D flutter effect

                // Fade out logic for hearts
                if (type === 'hearts') {
                    p.opacity -= 0.005; 
                    p.size *= 0.995; // Shrink slightly
                }
                
                // Draw
                ctx.save();
                ctx.globalAlpha = p.opacity;
                ctx.translate(p.x + p.tilt, p.y);
                ctx.rotate(p.rotation * Math.PI / 180);
                ctx.fillStyle = p.color;
                
                if (type === 'hearts') {
                    // Better Heart Shape Drawing
                    const scale = p.size / 10; // Normalize size
                    ctx.scale(scale, scale);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.bezierCurveTo(-5, -5, -10, 0, 0, 10);
                    ctx.bezierCurveTo(10, 0, 5, -5, 0, 0);
                    ctx.fill();
                } else {
                    // 3D Confetti Rectangle
                    ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
                }
                ctx.restore();
                
                p.rotation += p.rotationSpeed;
                
                // Check if still visible
                if (type === 'hearts') {
                    if (p.opacity > 0 && p.y > -50) active = true;
                } else {
                    if (p.y < canvas.height) active = true;
                }
            });
            
            if(active) requestAnimationFrame(animate);
            else ctx.clearRect(0,0, canvas.width, canvas.height);
        }
        animate();
    }
    
    // Check keywords
    function checkKeywords(text) {
        const lower = text.toLowerCase();
        if (lower.includes('love') || lower.includes('') || lower.includes('meena') || lower.includes('') || lower.includes('')) {
            fireEffect('hearts');
        } else if (lower.includes('congratulations') || lower.includes('happy birthday') || lower.includes('party') || lower.includes('')) {
            fireEffect('confetti');
        }
    }

    function linkify(text) {
        if (!text) return "";
        const urlRegex = /(https?:\/\/[^\s]+)/g;
        return text.replace(urlRegex, function(url) {
            return `<a onclick="event.stopPropagation(); window.open('${url}', '_blank')">${url}</a>`;
        });
    }

    function scrollToAndFlash(textSnippet) {
        const bubbles = document.querySelectorAll('.bubble span');
        let targetId = null;
        for(let span of bubbles) {
            if(span.innerText.includes(textSnippet)) {
                targetId = span.id.replace('text-', '');
                break;
            }
        }
        if(targetId) {
            const el = document.getElementById(targetId);
            if(el) {
                el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                const bubble = el.querySelector('.bubble') || el.closest('.bubble');
                if(bubble) {
                    bubble.style.animation = 'none';
                    bubble.offsetHeight; 
                    bubble.style.animation = 'flashMessage 1s ease';
                }
            }
        }
    }

    function triggerReply(text) {
        replyingTo = text;
        document.getElementById('reply-text').innerText = "Replying to: " + (text.length > 50 ? text.substring(0,50)+"..." : text);
        document.getElementById('reply-dock').style.display = 'flex';
        mInput.focus(); 
    }

    function cancelInteraction() { 
        if (editModeId) {
            mInput.value = "";
            mInput.style.height = 'auto';
        }
        replyingTo = null; 
        editModeId = null;
        document.getElementById('reply-dock').style.display = 'none'; 
    }

    // =========================================
    //  19. MESSAGING CORE ACTIONS
    // =========================================
    
    async function sendImageMessage(imageUrl) {
        popSound.play().catch(e => {});
        scrollToBottom(true);

        let msgData = {
            text: "", 
            sender: myUid, 
            timestamp: firebase.firestore.FieldValue.serverTimestamp(),
            replyTo: replyingTo, 
            seen: false, 
            reactions: {},
            imageUrl: imageUrl
        };
        cancelInteraction();
        await db.collection("chats").doc(chatId).collection("messages").add(msgData);
        updateLastMsg(" Image");
        updateInboxCacheLocal(chatId, " Image", myUid, false); // INBOX SYNC
        scrollToBottom(true);
    }

    async function sendFileMessage(fileUrl, metadata) {
        popSound.play().catch(e => {});
        scrollToBottom(true);
        const caption = metadata.caption || "";
        
        let msgData = {
            text: caption,
            sender: myUid, 
            timestamp: firebase.firestore.FieldValue.serverTimestamp(),
            replyTo: replyingTo, 
            seen: false, 
            reactions: {},
            fileUrl: fileUrl,
            fileMeta: metadata
        };
        cancelInteraction();
        await db.collection("chats").doc(chatId).collection("messages").add(msgData);
        let label = " File";
        if(metadata.type && metadata.type.indexOf('video') !== -1) label = " Video";
        else if(metadata.type && metadata.type.indexOf('audio') !== -1) label = " Audio";
        updateLastMsg(caption ? label + " " + caption : label);
        updateInboxCacheLocal(chatId, caption ? label + " " + caption : label, myUid, false); // INBOX SYNC
        scrollToBottom(true);
    }

    async function sendMsg() {
        const text = mInput.value.trim();
        if (!text) {
            inputBox.classList.add('shake-anim');
            setTimeout(() => inputBox.classList.remove('shake-anim'), 400);
            return;
        }

        popSound.play().catch(e => {});
        
        // Trigger Effects
        checkKeywords(text);
        
        mInput.value = "";
        mInput.style.height = 'auto'; 
        sendBtnUI.classList.remove('active'); 
        // Re-show mic button if empty
        micWrapper.style.display = 'flex';
        
        emojiTray.style.display = 'none';
        attachmentMenu.style.display = 'none';
        rdb.ref(`typing/${chatId}/${myUid}`).set(false);
        mInput.focus(); 

        if (editModeId) {
            const idToEdit = editModeId; editModeId = null;
            cancelInteraction(); 
            await db.collection("chats").doc(chatId).collection("messages").doc(idToEdit).update({ text, edited: true });
        } else {
            const rText = replyingTo; cancelInteraction(); 
            scrollToBottom(true);
            let msgData = {
                text, sender: myUid, timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                replyTo: rText, seen: false, reactions: {}
            };
            await db.collection("chats").doc(chatId).collection("messages").add(msgData);
            updateLastMsg(text);
            updateInboxCacheLocal(chatId, text, myUid, false); // INBOX SYNC
        }
        scrollToBottom(true);
    }

    async function updateLastMsg(msgText) {
        await db.collection("chats").doc(chatId).set({
            lastMessage: msgText, 
            lastSender: myUid,
            lastTimestamp: firebase.firestore.FieldValue.serverTimestamp(),
            participants: [myUid, targetUid], seen: false,
            [`unreadCount.${targetUid}`]: firebase.firestore.FieldValue.increment(1)
        }, { merge: true });
        updateInboxCacheLocal(chatId, msgText, myUid, false); // INBOX SYNC FALLBACK
    }

    // Menu & Edit Actions
    function openMenu(id, sender, text) {
        activeMenuId = id;
        const isMine = sender === myUid;
        document.getElementById('edit-btn').style.display = (isMine && text) ? 'block' : 'none'; 
        document.getElementById('unsend-btn').style.display = isMine ? 'block' : 'none';
        document.getElementById('menu-emoji-grid').style.display = 'none';
        document.getElementById('menu-overlay').style.display = 'flex';
        pushModalState('menu');
    }

    async function copyMessageText() {
        if (!activeMenuId) return;
        const el = document.getElementById('text-' + activeMenuId);
        if(!el) { closeMenu(); return; } 
        const msgText = el.innerText.split('(edited)')[0].trim();
        try {
            await navigator.clipboard.writeText(msgText);
            closeMenu();
        } catch (err) {}
    }

    function initEdit() {
        const el = document.getElementById('text-'+activeMenuId);
        if(!el) return;
        const textToEdit = el.innerText.split('(edited)')[0].trim();
        mInput.value = textToEdit;
        mInput.style.height = 'auto'; 
        mInput.style.height = mInput.scrollHeight + 'px';
        editModeId = activeMenuId; 
        closeMenu(); 
        document.getElementById('reply-text').innerHTML = "<strong style='color:#FF9800'>Editing Message:</strong><br> " + textToEdit;
        document.getElementById('reply-dock').style.display = 'flex';
        mInput.focus();
    }

    async function unsendMsg() { 
        const idToDelete = activeMenuId; closeMenu();
        // Optimistic Remove
        if (messagesMap.has(idToDelete)) { 
            messagesMap.delete(idToDelete); 
            // Also force remove from DOM immediately
            const el = document.getElementById(idToDelete);
            if(el) el.remove();
            renderAll(); 
        }
        
        await db.collection("chats").doc(chatId).collection("messages").doc(idToDelete).delete();
        const snapshot = await db.collection("chats").doc(chatId).collection("messages").orderBy("timestamp", "desc").limit(1).get();
        if (!snapshot.empty) {
            const lastMsg = snapshot.docs[0].data();
            let txt = lastMsg.text || "";
            
            // Logic to determine type of the NEW last message
            if (lastMsg.imageUrl) {
                txt = txt ? " " + txt : " Image";
            } else if (lastMsg.fileUrl) {
                const type = lastMsg.fileMeta ? lastMsg.fileMeta.type : 'file';
                let icon = "";
                let label = "File";
                if(type.indexOf('video') !== -1) { icon = ""; label = "Video"; }
                else if(type.indexOf('audio') !== -1) { icon = ""; label = "Audio"; }
                
                txt = txt ? `${icon} ${txt}` : `${icon} ${label}`;
            }
            
            await db.collection("chats").doc(chatId).update({ lastMessage: txt, lastSender: lastMsg.sender, lastTimestamp: lastMsg.timestamp });
            updateInboxCacheLocal(chatId, txt, lastMsg.sender, false); // INBOX SYNC
        }
    }

    async function loadMoreMessages() {
        if (isLoadingMore || !lastVisible) return;
        isLoadingMore = true;
        
        chatFlow.style.scrollBehavior = 'auto'; 
        const oldScrollHeight = chatFlow.scrollHeight;
        
        const snapshot = await db.collection("chats").doc(chatId).collection("messages")
            .orderBy("timestamp", "desc")
            .startAfter(lastVisible)
            .limit(15)
            .get();

        if (!snapshot.empty) {
            snapshot.forEach(doc => { 
                let d = doc.data(); 
                d.id = doc.id; 
                messagesMap.set(doc.id, d); 
            });
            lastVisible = snapshot.docs[snapshot.docs.length - 1];
            renderAll();
            // NEW FIX: Use requestAnimationFrame to let DOM paint the new top messages smoothly before calculating scroll anchoring height.
            requestAnimationFrame(() => {
                chatFlow.scrollTop = chatFlow.scrollHeight - oldScrollHeight;
                setTimeout(() => { 
                    chatFlow.style.scrollBehavior = 'smooth'; 
                    isLoadingMore = false;
                }, 50);
            });
        } else {
            isLoadingMore = false;
            lastVisible = null; 
        }
    }

    function setupObserver() {
        const observer = new IntersectionObserver((entries) => {
            if (entries[0].isIntersecting && !isLoadingMore && lastVisible) {
                loadMoreMessages();
            }
        }, { root: chatFlow, rootMargin: "400px", threshold: 0.01 }); // MODIFIED: Load seamlessly before hitting top
        observer.observe(document.getElementById('scroll-trigger'));
    }

    // MODIFIED: Added smooth scroll parameter
    function scrollToBottom(smooth = false) { 
        chatFlow.scrollTo({
            top: chatFlow.scrollHeight,
            behavior: smooth ? 'smooth' : 'auto'
        });
    }

    // Reaction Logic
    async function applyReaction(emoji) {
        if (!activeMenuId) return;
        const msgId = activeMenuId; closeMenu(); 
        await applyReactionToId(msgId, emoji);
    }

    async function applyReactionToId(id, emoji) {
        // 1. Optimistic Update (Visual Pop Instant)
        triggerReactionPop(id, emoji);

        if(messagesMap.has(id)) {
            let msg = messagesMap.get(id);
            if(!msg.reactions) msg.reactions = {};

            if(msg.reactions[myUid] && msg.reactions[myUid].emoji === emoji) {
                 delete msg.reactions[myUid];
            } else if (emoji !== '') {
                 msg.reactions[myUid] = { emoji: emoji, timestamp: Date.now() };
            }
            messagesMap.set(id, msg);
            // Surgical Update
            updateReactionDOM(id, msg.reactions);
        }

        // 2. Firebase Update
        const msgRef = db.collection("chats").doc(chatId).collection("messages").doc(id);
        const doc = await msgRef.get();
        const data = doc.data();
        let currentReaction = (data.reactions && data.reactions[myUid]) ? data.reactions[myUid].emoji : null;

        if (currentReaction === emoji) {
            await msgRef.update({ [`reactions.${myUid}`]: firebase.firestore.FieldValue.delete() });
        } else {
            await msgRef.update({ [`reactions.${myUid}`]: { emoji: emoji, timestamp: Date.now() } });
        }
    }

    function showReactionDetails(msgId, event) {
        event.stopPropagation();
        const msgData = messagesMap.get(msgId);
        if (!msgData || !msgData.reactions) return;

        const listContainer = document.getElementById('react-list-items');
        listContainer.innerHTML = '';

        Object.entries(msgData.reactions).forEach(([uid, rData]) => {
            const isMe = uid === myUid;
            const pfpSrc = isMe ? (myUserData ? myUserData.photoURL : 'https://via.placeholder.com/40') : chatTargetData.photoURL;
            const name = isMe ? "You" : (chatTargetData.name || chatTargetData.username);
            const timeStr = formatTime12(new Date(rData.timestamp));

            const el = document.createElement('div');
            el.className = 'reactor-item';
            el.innerHTML = `
                <img src="${pfpSrc}" class="reactor-pfp">
                <div class="reactor-info">
                    <div class="reactor-name">${name}</div>
                    <div class="reactor-time">${timeStr}</div>
                </div>
                <div class="reactor-emoji">${rData.emoji}</div>
            `;
            listContainer.appendChild(el);
        });
        document.getElementById('reaction-details-overlay').style.display = 'flex';
        pushModalState('reactions');
    }

    function closeReactionDetails() { 
        const overlay = document.getElementById('reaction-details-overlay');
        if (overlay.style.display === 'flex') {
            overlay.style.display = 'none'; 
            if(history.state && history.state.modal === 'reactions') history.back();
        }
    }
    
    function initReplyFromActive() {
        const el = document.getElementById('text-'+activeMenuId);
        const text = el ? el.innerText.split('(edited)')[0].trim() : "Image";
        triggerReply(text);
        closeMenu();
    }
    
    function closeMenu() { 
        const overlay = document.getElementById('menu-overlay');
        if(overlay.style.display === 'flex') {
            overlay.style.display = 'none'; 
            if(history.state && history.state.modal === 'menu') history.back();
        }
    }

    // =========================================
    //  20. AUDIO RECORDER LOGIC (INSTAGRAM STYLE)
    // =========================================

    // Variables for Recorder
    let mediaRecorder = null;
    let audioChunks = [];
    let recStartTime = 0;
    let recInterval = null;
    let isRecording = false;
    let isLocked = false;
    let recStartY = 0;
    let recStartX = 0;
    let STORAGE_BUCKET = "public-files"; 
    
    // NEW: Guard flag to prevent multiple sends
    let isAudioProcessing = false;

    const recOverlay = document.getElementById('recording-overlay');
    const recTimer = document.getElementById('rec-timer');
    const cancelZone = document.getElementById('cancel-trash');
    const lockPill = document.getElementById('lock-pill');
    const cancelText = document.getElementById('rec-cancel-text');

    // -- HELPER: Upload to Supabase via FilePicker Component's Client --
    async function uploadAudioBlob(blob, duration) {
        // We look for the filePicker element to access its internal supabase client
        const fpElement = document.getElementById('file-picker');
        
        if (!fpElement || !fpElement.sbClient) {
            console.error("Supabase client not found on file-picker component");
            alert("Upload Error: Client not initialized");
            isAudioProcessing = false; // Reset lock
            return;
        }

        const sbClient = fpElement.sbClient; 
        const fileName = `voice_${Date.now()}_${myUid}.webm`;

        try {
            const { data, error } = await sbClient.storage.from(STORAGE_BUCKET)
                .upload(fileName, blob, { contentType: 'audio/webm' });

            if (error) throw error;

            const { data: publicData } = sbClient.storage.from(STORAGE_BUCKET).getPublicUrl(fileName);
            const downloadUrl = publicData.publicUrl;

            // Send to Firebase
            sendFileMessage(downloadUrl, {
                type: 'audio/webm',
                name: 'Voice Message',
                size: blob.size,
                duration: duration,
                caption: "" 
            });

        } catch (err) {
            console.error("Audio Upload Failed:", err);
            alert("Failed to send voice message");
        } finally {
            isAudioProcessing = false; // Reset lock always
        }
    }

    // -- RECORDER FUNCTIONS --

    async function startRecording() {
        if (!navigator.mediaDevices) return;
        if (isAudioProcessing) return; // Guard

        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorder = new MediaRecorder(stream);
            audioChunks = [];
            
            mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
            mediaRecorder.start();
            
            isRecording = true;
            isLocked = false;
            recStartTime = Date.now();
            
            // UI Update
            micBtn.classList.add('recording');
            recOverlay.style.display = 'flex';
            lockPill.classList.add('visible');
            cancelText.style.opacity = '1';
            
            // Notify Other User
            rdb.ref(`typing/${chatId}/${myUid}`).set('recording');
            
            vibrate(50);
            popSound.play().catch(()=>{});

            recInterval = setInterval(() => {
                const diff = Math.floor((Date.now() - recStartTime) / 1000);
                const m = Math.floor(diff / 60);
                const s = diff % 60;
                recTimer.innerText = `${m}:${s < 10 ? '0'+s : s}`;
            }, 1000);

        } catch (err) {
            console.error("Mic Error", err);
            alert("Microphone access needed");
        }
    }

    async function stopRecording(shouldSend) {
        if (!mediaRecorder || !isRecording) return;
        
        isRecording = false;
        mediaRecorder.stop();
        mediaRecorder.stream.getTracks().forEach(t => t.stop());
        
        clearInterval(recInterval);
        recTimer.innerText = "0:00";
        
        // Reset UI
        micBtn.classList.remove('recording');
        micBtn.classList.remove('locked');
        recOverlay.style.display = 'none';
        lockPill.classList.remove('visible');
        cancelZone.classList.remove('visible', 'active');
        
        rdb.ref(`typing/${chatId}/${myUid}`).set(false);

        if (shouldSend) {
            if(isAudioProcessing) return; // Guard double send
            isAudioProcessing = true; // Lock

            // Processing
            setTimeout(() => {
                const blob = new Blob(audioChunks, { type: 'audio/webm' });
                const duration = Math.ceil((Date.now() - recStartTime) / 1000);
                if (duration < 1) {
                      // Too short
                      vibrate(50);
                      isAudioProcessing = false; // Reset lock
                } else {
                      popSound.play().catch(()=>{}); 
                      uploadAudioBlob(blob, duration);
                }
            }, 200);
        } else {
            vibrate([30,50,30]); // Error vibe
        }
    }

    function lockRecording() {
        isLocked = true;
        isRecording = true; // Ensure state
        micBtn.classList.remove('recording');
        micBtn.classList.add('locked'); // Turns red/stop icon style
        lockPill.classList.remove('visible'); // Hide the hint
        cancelText.style.opacity = '0'; // Hide slide text
        
        vibrate(100);
    }

    // -- TOUCH HANDLERS --

    micBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (isLocked) {
            // If locked, tap stops and sends
            stopRecording(true);
            return;
        }
        if (isRecording) return; // Prevent double trigger
        
        recStartY = e.touches[0].clientY;
        recStartX = e.touches[0].clientX;
        startRecording();
    }, { passive: false });

    micBtn.addEventListener('touchmove', (e) => {
        if (!isRecording || isLocked) return;
        
        const currentY = e.touches[0].clientY;
        const currentX = e.touches[0].clientX;
        
        const diffY = recStartY - currentY; // Up is positive
        const diffX = recStartX - currentX; // Left is positive
        
        // 1. LOCK LOGIC (Slide Up)
        if (diffY > 50) {
            lockPill.style.transform = `translateY(-${diffY}px)`;
            if (diffY > 100) {
                lockRecording();
            }
        } else {
            lockPill.style.transform = '';
        }

        // 2. CANCEL LOGIC (Slide Left)
        if (diffX > 20) {
            cancelZone.classList.add('visible');
            recOverlay.style.opacity = Math.max(0.3, 1 - (diffX / 200)); // Fade out overlay
            
            if (diffX > 150) {
                cancelZone.classList.add('active'); // Trash turns red
                cancelText.innerText = "Release to Cancel";
                vibrate(10);
            } else {
                cancelZone.classList.remove('active');
                cancelText.innerText = "Slide to cancel";
                recOverlay.style.opacity = '1';
            }
        } else {
            cancelZone.classList.remove('visible');
        }
    }, { passive: false });

    micBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        
        if (isLocked) return; // Tap needed to stop if locked

        const endX = e.changedTouches[0].clientX;
        const diffX = recStartX - endX;

        if (diffX > 150) {
            stopRecording(false); // Cancelled
        } else {
            stopRecording(true); // Sent
        }
    });

    // =========================================
    //  21. MOBILE BACK BUTTON HANDLING (NEW)
    // =========================================
    function pushModalState(modalName) {
        history.pushState({modal: modalName}, null, "");
    }

    window.addEventListener('popstate', (e) => {
        // If state is null, user wants to go back or modals are closed
        // We manually check if any modal is open and force close it (redundancy)
        const modals = [
            { id: 'emoji-tray', style: 'block' },
            { id: 'attachment-menu', style: 'flex' },
            { id: 'reaction-picker-modal', style: 'flex' },
            { id: 'menu-overlay', style: 'flex' },
            { id: 'reaction-details-overlay', style: 'flex' }
        ];
        
        let modalClosed = false;
        modals.forEach(m => {
            const el = document.getElementById(m.id);
            if(el && el.style.display === m.style) {
                el.style.display = 'none';
                modalClosed = true;
            }
        });
        
        // If no modal was closed by popstate, and user intended to leave (e.state is null)
        // We allow the browser to continue back
        if(!modalClosed && !e.state) {
            // Browser handles navigation
        }
    });

</script>

<script src="components/call-notifier.js" defer></script>
<call-notifier></call-notifier>

</body>
</html>
