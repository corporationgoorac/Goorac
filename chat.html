<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Goorac | Quantum</title>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>

    <script src="components/emojiPicker.js" defer></script>

    <style>
        :root { 
            /* Subtle radial background for depth */
            --bg: radial-gradient(circle at center, #0a0a0a 0%, #000000 100%); 
            --header-bg: rgba(0,0,0,0.96);
            --accent: #0095f6; 
            --border: #262626; 
            --sent-bg: linear-gradient(135deg, #ff6b00 0%, #ff3b00 100%);
            --received-bg: #262626; 
            --text: #ffffff; 
            --text-secondary: #a8a8a8;
            --shimmer: linear-gradient(90deg, #1a1a1a 0%, #2a2a2a 50%, #1a1a1a 100%);
        }

        * { 
            box-sizing: border-box; -webkit-tap-highlight-color: transparent; 
            margin: 0; padding: 0; -webkit-touch-callout: none; 
            -webkit-font-smoothing: antialiased;
        }
        
        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            background: var(--bg);
            position: fixed; 
            left: 0; top: 0;
            margin: 0 !important;
            padding: 0 !important;
        }

        body { 
            -webkit-user-select: none; user-select: none; 
            color: var(--text); 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; 
        }

        /* --- STRICT COPY PASTE CONTROL --- */
        div, span, p, img, svg { -webkit-user-select: none; user-select: none; }
        
        input, textarea { 
            -webkit-user-select: text !important; 
            user-select: text !important; 
            outline: none; 
            font-family: inherit;
        }

        /* --- ANIMATIONS --- */
        @keyframes shimmer { 0% { background-position: -200px 0; } 100% { background-position: 200px 0; } }
        @keyframes flashMessage { 0% { background-color: rgba(255, 165, 0, 0.3); transform: scale(1.02); } 100% { background-color: transparent; transform: scale(1); } }
        @keyframes scaleIn { from { transform: scale(0); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        @keyframes fadeStatus { 0% { opacity: 0; transform: translateY(2px); } 100% { opacity: 1; transform: translateY(0); } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 10%, 30%, 50%, 70%, 90% { transform: translateX(-4px); } 20%, 40%, 60%, 80% { transform: translateX(4px); } }
        
        /* Modal Slide Up Animation */
        @keyframes slideUp {
            from { transform: translateY(100%); }
            to { transform: translateY(0); }
        }

        .shake-anim { animation: shake 0.4s ease-in-out; border-color: #ff3b00 !important; }

        .loading-shimmer {
            background: var(--shimmer); background-size: 400px 100%; animation: shimmer 1.2s ease-in-out infinite;
        }

        .app-container { 
            display: flex; flex-direction: column; height: 100vh; height: 100dvh; width: 100%; position: absolute; top: 0; left: 0; overflow: hidden;
        }

        /* --- HEADER ABSOLUTE (WEBVIEW FIX) --- */
        header { 
            position: absolute; /* Request: Absolute positioning */
            top: 0; left: 0; right: 0;
            padding: 0 16px;
            padding-top: calc(env(safe-area-inset-top) + 10px);
            height: calc(60px + env(safe-area-inset-top));
            background: var(--header-bg); 
            border-bottom: 1px solid var(--border); 
            display: flex; align-items: center; gap: 12px; 
            z-index: 2000; 
            backdrop-filter: blur(25px); -webkit-backdrop-filter: blur(25px);
        }

        .back-btn { font-size: 1.8rem; color: var(--accent); cursor: pointer; display: flex; align-items: center; justify-content: center; height: 40px; width: 30px; }

        .h-profile-group { display: flex; align-items: center; gap: 12px; cursor: pointer; flex: 1; overflow: hidden; }
        
        .pfp-container { position: relative; width: 38px; height: 38px; flex-shrink: 0; }
        .h-pfp { width: 100%; height: 100%; border-radius: 50%; object-fit: cover; background: #121212; border: 1px solid #333; transition: opacity 0.3s ease; }
        .online-dot { position: absolute; bottom: 0; right: 0; width: 10px; height: 10px; background: #00e676; border-radius: 50%; border: 2px solid #000; display: none; box-shadow: 0 0 4px rgba(0,230,118,0.5); }
        
        .h-info { display: flex; flex-direction: column; justify-content: center; gap: 1px; min-width: 0; }
        .h-name-wrapper { display: flex; align-items: center; gap: 4px; line-height: 1.1; }
        .h-name { font-weight: 700; font-size: 1rem; color: #fff; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .h-name:empty { height: 16px; width: 120px; border-radius: 4px; background: var(--shimmer); background-size: 400px 100%; animation: shimmer 1.2s infinite; }
        .h-username-sub { font-size: 0.75rem; color: var(--text-secondary); font-weight: 400; animation: fadeStatus 0.3s ease; }
        .v-badge { width: 14px; height: 14px; display: none; }

        .header-actions { display: flex; align-items: center; gap: 20px; margin-left: auto; padding-right: 5px; }
        .header-icon { width: 26px; height: 26px; cursor: pointer; fill: #ffffff; opacity: 0.9; transition: transform 0.2s, opacity 0.2s; }
        .header-icon:active { opacity: 0.6; transform: scale(0.9); }

        /* --- CHAT AREA --- */
        #chat-flow { 
            flex: 1; overflow-y: auto; overflow-x: hidden; padding: 15px 0; 
            display: flex; flex-direction: column; -webkit-overflow-scrolling: touch;
            background: transparent; overscroll-behavior-y: contain; position: relative;
            /* PADDING TOP to clear absolute header */
            padding-top: calc(75px + env(safe-area-inset-top)); 
            
            /* Hide Scrollbar */
            -ms-overflow-style: none; scrollbar-width: none;
            
            /* Initial State Hidden */
            opacity: 0; transition: opacity 0.2s ease-in;
        }
        #chat-flow::-webkit-scrollbar { display: none; }
        
        #messages-container { display: flex; flex-direction: column; padding: 0 14px; will-change: transform; width: 100%; padding-bottom: 30px; }

        #typing-indicator-bottom { display: none; margin-left: 56px; margin-bottom: 15px; background: #262626; width: 54px; height: 32px; border-radius: 16px; border-bottom-left-radius: 4px; align-items: center; justify-content: center; gap: 4px; padding: 0 12px; align-self: flex-start; }
        .typing-dot { width: 6px; height: 6px; background: #999; border-radius: 50%; animation: typingWave 1.3s linear infinite; }
        .typing-dot:nth-child(2) { animation-delay: -1.1s; }
        .typing-dot:nth-child(3) { animation-delay: -0.9s; }
        @keyframes typingWave { 0%, 60%, 100% { transform: translateY(0); } 30% { transform: translateY(-4px); } }

        #scroll-trigger { text-align: center; padding: 20px; color: #262626; font-size: 0.7rem; order: -1; }
        .date-divider { text-align: center; margin: 10px 0; font-size: 0.75rem; color: #fff; font-weight: 600; text-transform: capitalize; background: rgba(40,40,40,0.6); padding: 4px 10px; border-radius: 12px; align-self: center; width: fit-content; position: sticky; top: 10px; z-index: 5; backdrop-filter: blur(4px); }

        .msg-row { display: flex; width: 100%; margin-bottom: 6px; position: relative; flex-direction: column; }
        .msg-row.sent { align-items: flex-end; padding-right: 0px; }
        .msg-row.received { align-items: flex-start; }
        .received-inner-row { display: flex; align-items: flex-end; gap: 8px; max-width: 100%; }
        .msg-avatar { width: 30px; height: 30px; border-radius: 50%; object-fit: cover; flex-shrink: 0; margin-bottom: 4px; background: #121212; border: 1px solid #222; }

        .msg-bubble-box { position: relative; max-width: 78%; display: flex; flex-direction: column; transition: margin-bottom 0.2s; }
        .sent .msg-bubble-box { align-items: flex-end; }
        .received .msg-bubble-box { align-items: flex-start; }

        .bubble { padding: 12px 16px; border-radius: 20px; font-size: 1rem; line-height: 1.45; position: relative; word-wrap: break-word; z-index: 2; box-shadow: 0 1px 2px rgba(0,0,0,0.15); }
        .sent .bubble { background: var(--sent-bg); color: #fff; border-top-right-radius: 18px; border-top-left-radius: 18px; border-bottom-left-radius: 18px; border-bottom-right-radius: 4px; text-align: left; }
        .received .bubble { background: var(--received-bg); color: #fff; border-top-left-radius: 18px; border-top-right-radius: 18px; border-bottom-right-radius: 18px; border-bottom-left-radius: 4px; text-align: left; }
        
        /* OWN FEATURE: Link Styling */
        .bubble a { color: #87ceeb; text-decoration: underline; cursor: pointer; }

        .sliding-timestamp { position: absolute; top: 50%; transform: translateY(-50%); right: -65px; font-size: 0.7rem; color: #666; font-weight: 500; width: 50px; text-align: center; pointer-events: none; }
        .reaction-badge { position: absolute; bottom: -12px; background: #1a1a1a; border: 2px solid #000; border-radius: 20px; padding: 4px 7px; font-size: 0.85rem; z-index: 10; display: none; cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.3); }
        .sent .reaction-badge { right: 0; }
        .received .reaction-badge { left: 0; }

        .seen-status { font-size: 0.65rem; color: var(--text-secondary); margin-top: 4px; margin-right: 2px; text-align: right; font-weight: 500; height: 14px; width: 100%; opacity: 0; animation: fadeIn 0.3s forwards; position: relative; z-index: 1; }
        @keyframes fadeIn { to { opacity: 1; } }

        .reply-box-ui { background: rgba(0, 0, 0, 0.25); padding: 10px 14px; border-radius: 12px; margin-bottom: 6px; font-size: 0.88rem; border-left: 4px solid rgba(255, 255, 255, 0.5); color: #e0e0e0; max-width: 100%; cursor: pointer; transition: opacity 0.2s; white-space: normal; display: -webkit-box; -webkit-line-clamp: 4; -webkit-box-orient: vertical; overflow: hidden; line-height: 1.35; }
        .reply-box-ui:active { opacity: 0.7; }
        
        /* === NEW: PROFESSIONAL INSTAGRAM NOTE REPLY UI === */
        .note-reply-wrapper {
            margin-bottom: 8px;
            display: flex; flex-direction: column; align-items: center;
            max-width: 100%; cursor: pointer;
        }
        .note-reply-pill { 
            /* Fallback dark background if no color provided */
            background: #262626; 
            padding: 10px 16px; 
            border-radius: 22px; 
            display: inline-flex; flex-direction: column;
            align-items: center; justify-content: center;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            min-width: 120px; max-width: 220px; text-align: center;
            position: relative;
            transition: transform 0.2s;
        }
        .note-reply-pill:active { transform: scale(0.96); }
        
        .note-header-row {
            display: flex; align-items: center; gap: 5px;
            margin-bottom: 4px;
        }
        .note-mini-pfp {
            width: 16px; height: 16px; border-radius: 50%;
            background: #444; object-fit: cover;
        }
        .note-label {
            font-size: 0.65rem; font-weight: 700;
            text-transform: uppercase; letter-spacing: 0.5px;
            color: rgba(255,255,255,0.7);
        }
        
        .note-content-text {
            font-size: 0.9rem; font-weight: 600; color: #fff;
            line-height: 1.3; margin-bottom: 2px;
            display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden;
        }
        
        .note-song-tag {
            display: flex; align-items: center; gap: 4px;
            font-size: 0.65rem; color: rgba(255,255,255,0.8);
            margin-top: 4px; background: rgba(0,0,0,0.2);
            padding: 2px 8px; border-radius: 10px;
        }
        
        /* The little line connecting note to message */
        .note-connector {
            width: 2px; height: 8px; background: rgba(255,255,255,0.2);
            margin-top: -1px; margin-bottom: -4px; z-index: 0;
        }

        #scroll-down-btn { position: fixed; bottom: 85px; right: 20px; width: 42px; height: 42px; background: #262626; border-radius: 50%; display: none; align-items: center; justify-content: center; color: var(--accent); box-shadow: 0 4px 15px rgba(0,0,0,0.5); border: 1px solid #333; z-index: 900; cursor: pointer; font-size: 1.2rem; transition: all 0.3s ease; }
        #scroll-down-btn.new-msg { background: var(--accent); color: #fff; animation: bounce 1s infinite; }
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-5px); } }

        #heart-overlay { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0); font-size: 80px; pointer-events: none; z-index: 3000; text-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        @keyframes heartPop { 0% { transform: translate(-50%, -50%) scale(0); opacity: 0; } 50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; } 70% { transform: translate(-50%, -50%) scale(1); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(0); opacity: 0; } }

        .input-area-container { background: #000; border-top: 1px solid var(--border); padding-bottom: env(safe-area-inset-bottom, 10px); flex-shrink: 0; width: 100%; z-index: 1000; }
        .input-area { padding: 10px 12px; display: flex; align-items: flex-end; gap: 10px; }
        .input-box { flex: 1; background: #121212; border-radius: 22px; padding: 4px 14px; border: 1px solid #333; display: flex; align-items: center; min-height: 42px; transition: border-color 0.2s; }
        .msg-input { width: 100%; background: transparent; border: none; color: white; padding: 9px 0; font-size: 16px; resize: none; max-height: 120px; overflow-y: auto; line-height: 1.35; }
        .plus-btn { font-size: 26px; color: var(--accent); cursor: pointer; padding: 0 5px; height: 44px; display: flex; align-items: center; }
        .send-btn { background: transparent; border: none; font-weight: 600; font-size: 1rem; padding: 0 5px; height: 44px; display: flex; align-items: center; color: #444; pointer-events: none; transition: color 0.2s ease, text-shadow 0.2s ease; }
        .send-btn.active { color: var(--accent); cursor: pointer; pointer-events: auto; text-shadow: 0 0 12px rgba(0, 149, 246, 0.6); }

        #emoji-tray { display: none; background: #000; border-top: 1px solid var(--border); height: 280px; padding: 0; }

        #menu-overlay, #reaction-details-overlay { 
            display: none; position: fixed; inset: 0; 
            background: rgba(0, 0, 0, 0.6); z-index: 2000; 
            justify-content: center; align-items: center; backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px);
        }
        .menu-card { background: #1c1c1c; border-radius: 16px; width: 280px; overflow: hidden; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        .reaction-bar { display: flex; justify-content: space-evenly; padding: 16px 10px; border-bottom: 1px solid #333; }
        .reaction-bar span { font-size: 2rem; cursor: pointer; transition: transform 0.1s; }
        .reaction-bar span:active { transform: scale(1.3); }
        .more-emoji-trigger { background: #333; border-radius: 50%; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; font-size: 20px; color: #fff; cursor: pointer; }
        .menu-opt { padding: 16px; text-align: center; font-size: 1rem; border-bottom: 1px solid #333; color: #fff; }
        .menu-opt:active { background: #333; }
        
        #reply-dock { display: none; background: #111; padding: 12px 16px; border-top: 1px solid var(--border); justify-content: space-between; align-items: center; }

        .react-list-container { width: 85%; max-width: 340px; background: #1c1c1c; border-radius: 16px; overflow: hidden; display: flex; flex-direction: column; max-height: 50vh; }
        .react-list-header { padding: 16px; text-align: center; font-weight: 600; font-size: 1.1rem; border-bottom: 1px solid #333; position: relative; color: white;}
        .react-list-close { position: absolute; right: 16px; top: 16px; cursor: pointer; color: #888; }
        .reactor-item { display: flex; align-items: center; padding: 12px 16px; gap: 12px; border-bottom: 1px solid #2a2a2a; }
        .reactor-pfp { width: 42px; height: 42px; border-radius: 50%; object-fit: cover; background: #333; }
        .reactor-info { flex: 1; }
        .reactor-name { font-weight: 600; font-size: 0.9rem; color: #fff; }
        .reactor-time { font-size: 0.7rem; color: #888; margin-top: 2px; }
        .reactor-emoji { font-size: 1.4rem; }

        /* REACTION HALF-SCREEN MODAL */
        #reaction-picker-modal {
            display: none; position: fixed; inset: 0; z-index: 3000;
            background: rgba(0,0,0,0.5); backdrop-filter: blur(2px);
            align-items: flex-end; /* Bottom alignment */
        }
        .picker-modal-content {
            width: 100%; height: 55vh; /* Half screen */
            background: #1c1c1c;
            border-top-left-radius: 20px; border-top-right-radius: 20px;
            display: flex; flex-direction: column;
            animation: slideUp 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            overflow: hidden;
        }
        .picker-header {
            padding: 15px; display: flex; align-items: center; gap: 12px;
            border-bottom: 1px solid #333; color: white; font-weight: 600; font-size: 1rem;
        }
        .picker-drag-handle {
            width: 40px; height: 5px; background: #444; border-radius: 10px; margin: 0 auto;
        }
    </style>
</head>
<body>

<div id="heart-overlay">‚ù§Ô∏è</div>

<div id="scroll-down-btn" onclick="scrollToBottom()">‚¨á</div>

<div id="reaction-details-overlay" onclick="closeReactionDetails()">
    <div class="react-list-container" onclick="event.stopPropagation()">
        <div class="react-list-header">
            Reactions
            <div class="react-list-close" onclick="closeReactionDetails()">‚úï</div>
        </div>
        <div class="react-list-content" id="react-list-items"></div>
    </div>
</div>

<div id="reaction-picker-modal" onclick="closeReactionPicker()">
    <div class="picker-modal-content" onclick="event.stopPropagation()">
        <div style="padding:10px 0 5px 0;"><div class="picker-drag-handle"></div></div>
        <div class="picker-header">
            <span onclick="closeReactionPicker()" style="font-size:1.2rem; cursor:pointer;">‚úï</span>
            React
        </div>
        <div id="reaction-picker-container" style="flex:1; overflow:hidden;"></div>
    </div>
</div>

<div id="menu-overlay" onclick="closeMenu()">
    <div class="menu-card" id="main-menu-card" onclick="event.stopPropagation()">
        <div class="reaction-bar">
            <span onclick="applyReaction('‚ù§Ô∏è')">‚ù§Ô∏è</span>
            <span onclick="applyReaction('üòÇ')">üòÇ</span>
            <span onclick="applyReaction('üòÆ')">üòÆ</span>
            <span onclick="applyReaction('üò¢')">üò¢</span>
            <span onclick="applyReaction('üëç')">üëç</span>
            <div class="more-emoji-trigger" onclick="expandEmojiMenu()">+</div>
        </div>
        <div id="menu-emoji-grid"></div>
        <div class="menu-opt" onclick="copyMessageText()">Copy Text</div>
        <div class="menu-opt" onclick="initReplyFromActive()">Reply</div>
        <div id="edit-btn" class="menu-opt" onclick="initEdit()">Edit</div>
        <div id="unsend-btn" class="menu-opt" style="color:#ff3b30; font-weight: 600;" onclick="unsendMsg()">Unsend</div>
        <div class="menu-opt" onclick="closeMenu()" style="border-bottom:none; color: #888">Cancel</div>
    </div>
</div>

<div class="app-container" id="main-app">
    <header id="chat-header">
        <div class="back-btn" onclick="history.back()">‚Äπ</div>
        <div class="h-profile-group" onclick="goToProfile()">
            <div class="pfp-container">
                <img id="h-pfp" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class="h-pfp loading-shimmer">
                <div class="online-dot" id="h-online-dot"></div>
            </div>
            <div class="h-info">
                <div class="h-name-wrapper">
                    <div class="h-name" id="h-display-name"></div>
                    <img id="v-badge" src="https://img.icons8.com/color/48/verified-badge.png" class="v-badge">
                </div>
                <div class="h-username-sub" id="h-username-label"></div>
            </div>
        </div>
        <div class="header-actions">
            <svg class="header-icon" onclick="window.location.href='calls.html'" viewBox="0 0 24 24">
                <path d="M20.01 15.38c-1.23 0-2.42-.2-3.53-.56a.977.977 0 0 0-1.01.24l-1.57 1.97c-2.83-1.44-5.15-3.75-6.59-6.59l1.97-1.57c.22-.22.3-.54.24-1.01a11.36 11.36 0 0 1-.56-3.53c0-.55-.45-1-1-1H4.39c-.55 0-1 .45-1 1c0 9.39 7.61 17 17 17c.55 0 1-.45 1-1v-3.56c0-.55-.45-1-1-1z"/>
            </svg>
            <svg class="header-icon" onclick="window.location.href='calls.html'" viewBox="0 0 24 24">
                <path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"/>
            </svg>
        </div>
    </header>

    <div id="chat-flow">
        <div id="scroll-trigger"></div>
        <div id="messages-container"></div>
        <div id="typing-indicator-bottom">
            <div class="typing-dot"></div>
            <div class="typing-dot"></div>
            <div class="typing-dot"></div>
        </div>
    </div>

    <div class="input-area-container">
        <div id="reply-dock">
            <div id="reply-text" style="font-size:0.8rem; color:#aaa; overflow:hidden; text-overflow:ellipsis;"></div>
            <div onclick="cancelInteraction()" style="color:#fff; font-weight:bold; padding:5px; cursor:pointer;">‚úï</div>
        </div>

        <div id="emoji-tray">
             <emoji-picker id="main-picker" style="width:100%; height:100%;"></emoji-picker>
        </div>

        <div class="input-area">
            <div class="plus-btn" onclick="toggleEmojiTray()">+</div>
            <div class="input-box" id="msg-input-box">
                <textarea id="m-input" class="msg-input" placeholder="Message..." rows="1"></textarea>
            </div>
            <button id="send-btn" class="send-btn">Send</button>
        </div>
    </div>
</div>

<script>
    const firebaseConfig = {
        apiKey: "AIzaSyCFzAEHC5KLiO2DEkVtoTlFn9zeCQrwImE",
        authDomain: "goorac-c3b59.firebaseapp.com",
        projectId: "goorac-c3b59",
        storageBucket: "goorac-c3b59.firebasestorage.app",
        messagingSenderId: "746746595332",
        appId: "1:746746595332:web:d3f8527d27fe8ca2530d51",
        databaseURL: "https://goorac-c3b59-default-rtdb.firebaseio.com"
    };

    if (!firebase.apps.length) {
        firebase.initializeApp(firebaseConfig);
    }
    const db = firebase.firestore();
    const rdb = firebase.database();
    const auth = firebase.auth();

    const params = new URLSearchParams(window.location.search);
    const targetUsername = params.get('user');
    let myUid, targetUid, chatId, replyingTo = null, editModeId = null;
    let activeMenuId = null, unsubscribe = null, isLoadingMore = false;
    let lastVisible = null; 
    let messagesMap = new Map(); 
    let chatTargetData = null; 
    let myUserData = null;
    let isFirstLoad = true;
    let statusTimeout = null;
    
    // NEW: Variables for periodic status update
    let lastStatusData = null;
    let statusUpdateInterval = null;
    
    // NEW: First load flag for header logic
    let isFirstStatusLoad = true;

    // Custom Feature: Sound Effect (Base64 Pop & Like)
    const popSound = new Audio("data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU"); 
    const likeSound = new Audio("data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU"); 

    const mInput = document.getElementById('m-input');
    const inputBox = document.getElementById('msg-input-box');
    const chatFlow = document.getElementById('chat-flow');
    const container = document.getElementById('messages-container');
    const bottomTyping = document.getElementById('typing-indicator-bottom');
    const emojiTray = document.getElementById('emoji-tray');
    const scrollBtn = document.getElementById('scroll-down-btn');
    const sendBtnUI = document.getElementById('send-btn');
    const onlineDot = document.getElementById('h-online-dot');
    const headerSubLabel = document.getElementById('h-username-label');

    // UNWANTED EMOJIS REMOVED HERE

    // NEW: Double Tap on Background to Scroll Down
    document.addEventListener('dblclick', (e) => {
        if (e.target.id === 'chat-flow' || e.target.id === 'messages-container') {
            scrollToBottom();
            vibrate(30);
        }
    });
    
    // NEW: Global Ripple Effect
    document.addEventListener('click', function(e) {
        if(e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.closest('emoji-picker')) return;
        const circle = document.createElement('div');
        circle.style.width = circle.style.height = '15px';
        circle.style.left = `${e.clientX}px`;
        circle.style.top = `${e.clientY}px`;
        circle.classList.add('ripple');
        document.body.appendChild(circle);
        setTimeout(() => circle.remove(), 600);
    });
    
    // === KEYBOARD FIX: Prevent focus loss on Send Button ===
    const handleSendClick = (e) => {
        e.preventDefault(); // Stop button from stealing focus
        sendMsg();
    };

    sendBtnUI.addEventListener('mousedown', handleSendClick);
    sendBtnUI.addEventListener('touchstart', handleSendClick);

    function formatTime12(date) {
        let hours = date.getHours();
        let minutes = date.getMinutes();
        let ampm = hours >= 12 ? 'PM' : 'AM';
        hours = hours % 12;
        hours = hours ? hours : 12;
        minutes = minutes < 10 ? '0'+minutes : minutes;
        return hours + ':' + minutes + ' ' + ampm;
    }

    // Helper for "Seen 1m ago" & Active status
    function timeAgo(date) {
        const seconds = Math.floor((new Date() - date) / 1000);
        let interval = seconds / 31536000;
        if (interval > 1) return Math.floor(interval) + "y ago";
        interval = seconds / 2592000;
        if (interval > 1) return Math.floor(interval) + "mo ago";
        interval = seconds / 86400;
        if (interval > 1) return Math.floor(interval) + "d ago";
        interval = seconds / 3600;
        if (interval > 1) return Math.floor(interval) + "h ago";
        interval = seconds / 60;
        if (interval > 1) return Math.floor(interval) + "m ago";
        return "Just now";
    }

    function formatActiveTime(timestamp) {
        if (!timestamp) return "";
        const now = Date.now();
        const diff = now - timestamp;
        if (diff < 60000) return "Active now";
        return "Active " + timeAgo(new Date(timestamp));
    }

    function getDateDivider(date) {
        const today = new Date();
        const yesterday = new Date();
        yesterday.setDate(today.getDate() - 1);
        if (date.toDateString() === today.toDateString()) return "Today";
        if (date.toDateString() === yesterday.toDateString()) return "Yesterday";
        return date.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
    }

    // Auto-resize textarea & Send Button Animation
    mInput.addEventListener('input', function() {
        this.style.height = 'auto'; 
        this.style.height = (this.scrollHeight) + 'px';
        if(this.value === '') this.style.height = 'auto';
        
        if(this.value.trim().length > 0) {
            sendBtnUI.classList.add('active');
        } else {
            sendBtnUI.classList.remove('active');
        }

        rdb.ref(`typing/${chatId}/${myUid}`).set(this.value.trim().length > 0);
        
        // Own Feature: Auto-Scroll on Typing
        if(chatFlow.scrollHeight - chatFlow.scrollTop - chatFlow.clientHeight < 100) {
             scrollToBottom();
        }
    });

    // Handle Enter key - Modified as per request
    mInput.addEventListener('keydown', (e) => {
        // Enter creates new line, so we do nothing here (default behavior)
        // Only explicitly shift+enter might be useful, but standard Enter = Next Line
    });
    
    // --- SCROLL BUTTON VISIBILITY LOGIC ---
    chatFlow.addEventListener('scroll', () => {
        const diff = chatFlow.scrollHeight - chatFlow.scrollTop - chatFlow.clientHeight;
        if (diff > 250) {
            scrollBtn.style.display = 'flex';
        } else {
            scrollBtn.style.display = 'none';
            scrollBtn.classList.remove('new-msg');
        }
    });

    // --- FIX: ALLOW PASTE BUT DISABLE RIGHT CLICK ELSEWHERE ---
    window.oncontextmenu = (e) => { 
        if(e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return true;
        e.preventDefault(); 
        return false; 
    };
    
    // --- COMPONENT INTEGRATION ---
    const mainPicker = document.getElementById('main-picker');
    if(mainPicker) {
        mainPicker.addEventListener('emoji-click', event => {
            const emoji = event.detail.emoji || event.detail.unicode; 
            mInput.value += emoji;
            mInput.focus();
            mInput.dispatchEvent(new Event('input'));
        });
    }

    function toggleEmojiTray() {
        if (emojiTray.style.display === 'block') {
            emojiTray.style.display = 'none';
        } else {
            emojiTray.style.display = 'block';
        }
        scrollToBottom();
    }
    
    // Reaction Picker Logic (Half Screen Modal Component)
    // Updated to ensure component usage for reactions
    function expandEmojiMenu() {
        closeMenu();
        const reactionModal = document.getElementById('reaction-picker-modal');
        const container = document.getElementById('reaction-picker-container');
        container.innerHTML = ''; 
        
        // Dynamically create the component
        const reactionPicker = document.createElement('emoji-picker');
        reactionPicker.style.width = "100%";
        reactionPicker.style.height = "100%";
        reactionPicker.addEventListener('emoji-click', event => {
             const emoji = event.detail.emoji || event.detail.unicode;
             applyReaction(emoji);
             closeReactionPicker(); // Auto-close on selection (Fast Interaction)
        });
        container.appendChild(reactionPicker);
        reactionModal.style.display = 'flex';
    }

    function closeReactionPicker() {
        document.getElementById('reaction-picker-modal').style.display = 'none';
    }

    if (window.visualViewport) {
        window.visualViewport.addEventListener('resize', () => {
            const viewportHeight = window.visualViewport.height;
            document.getElementById('main-app').style.height = viewportHeight + 'px';
            document.body.style.top = window.visualViewport.offsetTop + 'px';
            scrollToBottom();
        });
    }

    function vibrate(ms = 50) { if (navigator.vibrate) navigator.vibrate(ms); }

    function goToProfile() {
        if(targetUsername) window.location.href = `userProfile.html?user=${targetUsername}`;
    }
    
    mInput.addEventListener("focus", () => { emojiTray.style.display = 'none'; });

    // --- REALTIME PRESENCE SYSTEM ---
    function setupMyPresence() {
        const userStatusDatabaseRef = rdb.ref('/status/' + myUid);
        rdb.ref('.info/connected').on('value', (snapshot) => {
            if (snapshot.val() == false) return;
            userStatusDatabaseRef.onDisconnect().set({
                state: 'offline',
                last_changed: firebase.database.ServerValue.TIMESTAMP
            }).then(() => {
                userStatusDatabaseRef.set({
                    state: 'online',
                    last_changed: firebase.database.ServerValue.TIMESTAMP
                });
            });
        });
    }

    // === UPDATED: Function to update header UI based on latest data ===
    function updateHeaderStatus() {
        if (!lastStatusData) return;
        
        // Check typing status first (priority)
        const isTyping = bottomTyping.style.display === 'flex';
        if (isTyping) return; // Don't overwrite "Typing..."

        if (lastStatusData.state === 'online') {
            onlineDot.style.display = 'block';
            headerSubLabel.innerText = "Active now";
            headerSubLabel.style.color = "#00e676";
        } else {
            onlineDot.style.display = 'none';
            headerSubLabel.innerText = formatActiveTime(lastStatusData.last_changed);
            headerSubLabel.style.color = "var(--text-secondary)";
        }
    }

    function monitorTargetStatus() {
        if (!targetUid) return;
        
        // Clear any existing interval
        if (statusUpdateInterval) clearInterval(statusUpdateInterval);

        // Start interval to refresh time every 60s
        statusUpdateInterval = setInterval(() => {
            if (!isFirstStatusLoad) {
                updateHeaderStatus();
            }
        }, 60000);

        rdb.ref('/status/' + targetUid).on('value', (snapshot) => {
            lastStatusData = snapshot.val();
            
            // Only update immediately if not typing
            if (statusTimeout) clearTimeout(statusTimeout);
            
            // Initial simple state
            if (!lastStatusData) {
               headerSubLabel.innerText = `@${chatTargetData.username}`;
               headerSubLabel.style.color = "var(--text-secondary)";
               return;
            }

            // === NEW LOGIC: SHOW USERNAME FIRST 3 SECONDS ===
            if (isFirstStatusLoad) {
                // Force show username
                headerSubLabel.innerText = `@${chatTargetData.username}`;
                headerSubLabel.style.color = "var(--text-secondary)";
                onlineDot.style.display = 'none';

                // Wait 3 seconds, then switch to live status
                statusTimeout = setTimeout(() => {
                    isFirstStatusLoad = false;
                    updateHeaderStatus(); 
                }, 3000);
            } else {
                // Normal live update
                if(bottomTyping.style.display !== 'flex') {
                    // Small delay to prevent jitter
                    statusTimeout = setTimeout(() => {
                        updateHeaderStatus();
                    }, 500); 
                }
            }
        });
    }

    auth.onAuthStateChanged(user => {
        if (user) { 
            myUid = user.uid; 
            db.collection('users').doc(myUid).get().then(doc => {
                 if (doc.exists) myUserData = doc.data();
            });
            setupMyPresence();
            initChat(); 
        }
        else { window.location.href = 'login.html'; }
    });

    async function initChat() {
        if(!targetUsername) return;
        const snap = await db.collection("users").where("username", "==", targetUsername).get();
        if (snap.empty) return;
        targetUid = snap.docs[0].id;
        chatId = myUid < targetUid ? `${myUid}_${targetUid}` : `${targetUid}_${myUid}`;
        
        chatTargetData = snap.docs[0].data();
        
        const pfp = document.getElementById('h-pfp');
        pfp.classList.remove('loading-shimmer');
        pfp.src = chatTargetData.photoURL || 'https://via.placeholder.com/150';
        
        document.getElementById('h-display-name').innerText = chatTargetData.name || chatTargetData.username;
        document.getElementById('h-username-label').innerText = `@${chatTargetData.username}`;
        
        if(chatTargetData.verified === true) document.getElementById('v-badge').style.display = 'block';

        monitorTargetStatus();

        db.collection("chats").doc(chatId).update({ 
            [`unreadCount.${myUid}`]: 0, 
            seen: true 
        }).catch(e => {});

        rdb.ref(`typing/${chatId}/${targetUid}`).on('value', (s) => {
            const isTyping = s.val();
            bottomTyping.style.display = isTyping ? 'flex' : 'none';
            if(isTyping) {
                if (statusTimeout) clearTimeout(statusTimeout);
                headerSubLabel.innerText = "Typing...";
                headerSubLabel.style.color = "#00e676";
                scrollToBottom();
            } else {
                updateHeaderStatus(); // Revert to status
            }
        });

        startListener(); 
        setupObserver();
        setupGlobalSlide(); 
    }

    // --- INSTAGRAM STYLE TIME REVEAL LOGIC ---
    function setupGlobalSlide() {
        let startX = 0, currentX = 0, isDragging = false;
        const container = document.getElementById('messages-container');

        chatFlow.addEventListener('touchstart', (e) => {
            startX = e.touches[0].clientX;
            isDragging = false;
        }, {passive: true});

        chatFlow.addEventListener('touchmove', (e) => {
            currentX = e.touches[0].clientX;
            const diff = currentX - startX;
            if (diff < -10) { 
                isDragging = true;
                const translate = Math.max(diff, -70);
                container.style.transform = `translateX(${translate}px)`;
                container.style.transition = 'none';
            }
        }, {passive: true});

        chatFlow.addEventListener('touchend', (e) => {
            if (isDragging) {
                container.style.transition = 'transform 0.2s cubic-bezier(0.215, 0.610, 0.355, 1.000)';
                container.style.transform = `translateX(0px)`;
            }
            startX = 0; currentX = 0; isDragging = false;
        });
    }

    function setupObserver() {
        const observer = new IntersectionObserver((entries) => {
            if (entries[0].isIntersecting && !isLoadingMore && lastVisible) {
                loadMoreMessages();
            }
        }, { root: chatFlow, threshold: 0.5 });
        observer.observe(document.getElementById('scroll-trigger'));
    }

    function startListener() {
        if (unsubscribe) unsubscribe();
        
        unsubscribe = db.collection("chats").doc(chatId).collection("messages")
            .orderBy("timestamp", "desc")
            .limit(20)
            .onSnapshot(snapshot => {
                if (snapshot.empty) return;
                
                if (!lastVisible) lastVisible = snapshot.docs[snapshot.docs.length - 1];
                let isNewIncoming = false;

                snapshot.docChanges().forEach(change => {
                    const msgData = change.doc.data();
                    const msgId = change.doc.id;
                    
                    if (change.type === "added") {
                        messagesMap.set(msgId, msgData);
                        if(msgData.sender !== myUid) isNewIncoming = true;
                    } else if (change.type === "modified") {
                        messagesMap.set(msgId, msgData);
                    } else if (change.type === "removed") {
                        messagesMap.delete(msgId);
                    }
                    
                    if(msgData.sender !== myUid && !msgData.seen) {
                        db.collection("chats").doc(chatId).collection("messages").doc(msgId).update({ 
                            seen: true,
                            seenAt: firebase.firestore.FieldValue.serverTimestamp() 
                        });
                    }
                });

                if(isNewIncoming) { 
                    vibrate(20);
                    if(chatFlow.scrollHeight - chatFlow.scrollTop - chatFlow.clientHeight > 250) {
                        scrollBtn.classList.add('new-msg');
                    }
                }

                // Initial Load Instant Jump
                if (isFirstLoad) {
                    renderAll();
                    chatFlow.scrollTop = chatFlow.scrollHeight;
                    setTimeout(() => {
                        chatFlow.style.opacity = '1';
                        isFirstLoad = false;
                    }, 50);
                } else {
                    const isNearBottom = chatFlow.scrollHeight - chatFlow.scrollTop - chatFlow.clientHeight < 300;
                    renderAll();
                    if (isNearBottom || isNewIncoming && isNearBottom) {
                        scrollToBottom();
                    }
                }
            });
    }

    async function loadMoreMessages() {
        if (isLoadingMore || !lastVisible) return;
        isLoadingMore = true;
        
        // CAPTURE SCROLL POS
        chatFlow.style.scrollBehavior = 'auto'; // Disable smooth for instant jump
        const oldScrollHeight = chatFlow.scrollHeight;
        
        const snapshot = await db.collection("chats").doc(chatId).collection("messages")
            .orderBy("timestamp", "desc")
            .startAfter(lastVisible)
            .limit(15)
            .get();

        if (!snapshot.empty) {
            snapshot.forEach(doc => { messagesMap.set(doc.id, doc.data()); });
            lastVisible = snapshot.docs[snapshot.docs.length - 1];
            renderAll();
            
            // ADJUST SCROLL POSITION INSTANTLY
            chatFlow.scrollTop = chatFlow.scrollHeight - oldScrollHeight;
            
            // Re-enable smooth after a tick
            setTimeout(() => { chatFlow.style.scrollBehavior = 'smooth'; }, 50);
            
            isLoadingMore = false;
        } else {
            isLoadingMore = false;
            lastVisible = null; 
        }
    }

    function renderAll() {
        container.innerHTML = '';
        const sorted = Array.from(messagesMap.entries())
            .filter(([id, data]) => data.timestamp) 
            .sort((a, b) => a[1].timestamp.toMillis() - b[1].timestamp.toMillis());

        let lastDateLabel = "";

        // Logic for Last Seen
        let lastSeenMsgId = null;
        for (let i = sorted.length - 1; i >= 0; i--) {
            const [id, data] = sorted[i];
            if (data.sender === myUid && data.seen === true) {
                lastSeenMsgId = id;
                break; 
            }
        }

        sorted.forEach(([id, data], index) => { 
            const msgDate = data.timestamp.toDate();
            const dateLabel = getDateDivider(msgDate);
            
            if (dateLabel !== lastDateLabel) {
                const div = document.createElement('div');
                div.className = "date-divider";
                div.innerText = dateLabel;
                container.appendChild(div);
                lastDateLabel = dateLabel;
            }

            // --- SMART PROFILE PICTURE LOGIC ---
            let isLastInGroup = true;
            if (index + 1 < sorted.length) {
                const nextMsg = sorted[index + 1][1];
                if (nextMsg.sender === data.sender) {
                    isLastInGroup = false;
                }
            }

            renderMessage(data, id, id === lastSeenMsgId, isLastInGroup); 
        });
    }

    function triggerHeartAnimation() {
        const h = document.getElementById('heart-overlay');
        h.style.animation = 'none';
        h.offsetHeight; 
        h.style.animation = 'heartPop 0.8s ease-out';
        likeSound.play().catch(e => {}); 
    }

    // Own Feature: Link Detection
    function linkify(text) {
        if (!text) return "";
        const urlRegex = /(https?:\/\/[^\s]+)/g;
        return text.replace(urlRegex, function(url) {
            return `<a onclick="event.stopPropagation(); window.open('${url}', '_blank')">${url}</a>`;
        });
    }

    function scrollToAndFlash(textSnippet) {
        const bubbles = document.querySelectorAll('.bubble span');
        let targetId = null;
        for(let span of bubbles) {
            if(span.innerText.includes(textSnippet)) {
                targetId = span.id.replace('text-', '');
                break;
            }
        }
        if(targetId) {
            const el = document.getElementById(targetId);
            if(el) {
                el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                const bubble = el.querySelector('.bubble') || el.closest('.bubble');
                if(bubble) {
                    bubble.style.animation = 'none';
                    bubble.offsetHeight; 
                    bubble.style.animation = 'flashMessage 1s ease';
                }
            }
        }
    }

    function renderMessage(m, id, isLastSeen, isLastInGroup) {
        const side = m.sender === myUid ? 'sent' : 'received';
        const date = m.timestamp ? m.timestamp.toDate() : new Date();

        const rowDiv = document.createElement('div');
        rowDiv.id = id;
        rowDiv.className = `msg-row ${side}`;
        
        let reactionsList = [];
        let myReaction = null;
        if (m.reactions) {
            reactionsList = Object.values(m.reactions);
            if (m.reactions[myUid]) myReaction = m.reactions[myUid].emoji;
        }
        const reactionDisplay = reactionsList.map(r => r.emoji).join(' ');

        let seenText = "";
        if (isLastSeen && side === 'sent') {
            if (m.seenAt) {
                seenText = "Seen " + timeAgo(m.seenAt.toDate());
            } else {
                seenText = "Seen"; 
            }
        }
        
        const boxStyle = reactionDisplay ? 'style="margin-bottom: 14px"' : '';
        const replyHtml = m.replyTo ? `<div class="reply-box-ui" onclick="event.stopPropagation(); scrollToAndFlash('${m.replyTo}')">‚§¥ ${m.replyTo}</div>` : '';

        // NEW: Unique Instagram-like Note Reply UI
        const noteReplyHtml = m.replyToNote ? `
            <div class="note-reply-wrapper">
                <div class="note-reply-pill" style="background: ${m.noteMetadata ? (m.noteMetadata.bgColor || '#262626') : '#262626'}; color: ${m.noteMetadata ? (m.noteMetadata.textColor || '#fff') : '#fff'}">
                    <div class="note-header-row">
                        <img src="${m.noteMetadata && m.noteMetadata.pfp ? m.noteMetadata.pfp : (chatTargetData ? chatTargetData.photoURL : 'https://via.placeholder.com/20')}" class="note-mini-pfp">
                        <span class="note-label">Replied to note</span>
                    </div>
                    <div class="note-content-text">"${m.replyToNote}"</div>
                    ${m.noteMetadata && m.noteMetadata.songName ? `
                    <div class="note-song-tag">
                        <svg viewBox="0 0 24 24" style="width:10px; fill:currentColor"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/></svg>
                        <span>${m.noteMetadata.songName}</span>
                    </div>` : ''}
                </div>
                <div class="note-connector"></div>
            </div>
        ` : '';

        // --- HTML ASSEMBLY ---
        const safeText = linkify(m.text);
        let innerHTML = '';
        if (side === 'received') {
            const pfpUrl = chatTargetData ? chatTargetData.photoURL : 'https://via.placeholder.com/30';
            const visibility = isLastInGroup ? 'visible' : 'hidden';
            innerHTML = `
                <div class="received-inner-row">
                    <img src="${pfpUrl}" class="msg-avatar" style="visibility: ${visibility}">
                    <div class="msg-bubble-box" ${boxStyle}>
                        ${noteReplyHtml}
                        ${replyHtml}
                        <div class="bubble" id="bubble-${id}">
                            <span id="text-${id}">${safeText} ${m.edited ? '<small style="opacity:0.4;font-size:0.6rem"> (edited)</small>' : ''}</span>
                            <div id="react-${id}" class="reaction-badge" onclick="showReactionDetails('${id}', event)" style="${reactionDisplay ? 'display:block' : ''}">${reactionDisplay}</div>
                        </div>
                    </div>
                </div>`;
        } else {
            innerHTML = `
                <div class="msg-bubble-box" ${boxStyle}>
                    ${noteReplyHtml}
                    ${replyHtml}
                    <div class="bubble" id="bubble-${id}">
                        <span id="text-${id}">${safeText} ${m.edited ? '<small style="opacity:0.4;font-size:0.6rem"> (edited)</small>' : ''}</span>
                        <div id="react-${id}" class="reaction-badge" onclick="showReactionDetails('${id}', event)" style="${reactionDisplay ? 'display:block' : ''}">${reactionDisplay}</div>
                    </div>
                </div>`;
        }

        rowDiv.innerHTML = `
            ${innerHTML}
            ${seenText ? `<div class="seen-status">${seenText}</div>` : ''}
            <div class="sliding-timestamp">${formatTime12(date)}</div>
        `;
        container.appendChild(rowDiv);

        const bubbleEl = rowDiv.querySelector(`#bubble-${id}`);
        if(bubbleEl) {
            bubbleEl.addEventListener('dblclick', (e) => {
                e.preventDefault(); e.stopPropagation(); vibrate(40);
                triggerHeartAnimation();
                applyReactionToId(id, myReaction === '‚ù§Ô∏è' ? '' : '‚ù§Ô∏è');
            });

            let startX = 0, currentX = 0, menuTimer = null, isScrolling = false, swipeTriggered = false;

            bubbleEl.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                const startY = e.touches[0].clientY;
                isScrolling = false; 
                swipeTriggered = false;
                
                menuTimer = setTimeout(() => {
                    if (!isScrolling) { vibrate(70); openMenu(id, m.sender, m.text); }
                }, 500);
            }, {passive: true});

            bubbleEl.addEventListener('touchmove', (e) => {
                currentX = e.touches[0].clientX;
                const currentY = e.touches[0].clientY;
                
                if (Math.abs(currentX - startX) > 10 || Math.abs(currentY - startX) > 10) { 
                     clearTimeout(menuTimer);
                     isScrolling = true;
                }
                
                let diff = currentX - startX;
                if (diff > 0 && diff < 80) {
                    bubbleEl.style.transform = `translateX(${diff}px)`;
                    bubbleEl.style.transition = "none";
                    if (diff > 50 && !swipeTriggered) { vibrate(20); swipeTriggered = true; }
                }
            }, {passive: true});

            bubbleEl.addEventListener('touchend', () => {
                clearTimeout(menuTimer);
                let diff = currentX - startX;
                bubbleEl.style.transition = "transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)";
                bubbleEl.style.transform = `translateX(0px)`;
                if (diff > 50 && swipeTriggered) triggerReply(m.text);
                startX = 0; currentX = 0;
            });
        }
    }

    function triggerReply(text) {
        replyingTo = text;
        document.getElementById('reply-text').innerText = "Replying to: " + replyingTo;
        document.getElementById('reply-dock').style.display = 'flex';
        mInput.focus(); 
    }

    async function sendMsg() {
        const text = mInput.value.trim();
        if (!text) {
            // New Feature: Input Shake on Empty Send
            inputBox.classList.add('shake-anim');
            setTimeout(() => inputBox.classList.remove('shake-anim'), 400);
            return;
        }

        popSound.play().catch(e => {});

        // KEYBOARD FIX: Clear value but DO NOT BLUR
        mInput.value = "";
        mInput.style.height = 'auto'; 
        
        sendBtnUI.classList.remove('active'); 
        emojiTray.style.display = 'none';
        rdb.ref(`typing/${chatId}/${myUid}`).set(false);
        
        // FORCE FOCUS TO REMAIN
        mInput.focus(); 
        // Forced refocus just in case
        setTimeout(() => mInput.focus(), 10); 

        if (editModeId) {
            const idToEdit = editModeId; editModeId = null;
            cancelInteraction(); // Close the editing dock
            await db.collection("chats").doc(chatId).collection("messages").doc(idToEdit).update({ text, edited: true });
        } else {
            const rText = replyingTo; cancelInteraction(); // Close reply dock
            scrollToBottom();
            await db.collection("chats").doc(chatId).collection("messages").add({
                text, sender: myUid, timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                replyTo: rText, seen: false, reactions: {}
            });
            await db.collection("chats").doc(chatId).set({
                lastMessage: text, lastSender: myUid,
                lastTimestamp: firebase.firestore.FieldValue.serverTimestamp(),
                participants: [myUid, targetUid], seen: false,
                [`unreadCount.${targetUid}`]: firebase.firestore.FieldValue.increment(1)
            }, { merge: true });
        }
        scrollToBottom();
    }

    function scrollToBottom() { 
        chatFlow.scrollTop = chatFlow.scrollHeight; 
    }

    function openMenu(id, sender, text) {
        activeMenuId = id;
        const isMine = sender === myUid;
        document.getElementById('edit-btn').style.display = isMine ? 'block' : 'none';
        document.getElementById('unsend-btn').style.display = isMine ? 'block' : 'none';
        document.getElementById('menu-emoji-grid').style.display = 'none';
        document.getElementById('menu-overlay').style.display = 'flex';
    }

    async function copyMessageText() {
        if (!activeMenuId) return;
        const msgText = document.getElementById('text-' + activeMenuId).innerText.split('(edited)')[0].trim();
        try {
            await navigator.clipboard.writeText(msgText);
            closeMenu();
        } catch (err) {
            console.error('Failed to copy: ', err);
        }
    }

    async function applyReaction(emoji) {
        if (!activeMenuId) return;
        const msgId = activeMenuId; closeMenu(); 
        await applyReactionToId(msgId, emoji);
    }

    async function applyReactionToId(id, emoji) {
        // --- 1. OPTIMISTIC UPDATE (Fix for old messages) ---
        if(messagesMap.has(id)) {
            let msg = messagesMap.get(id);
            if(!msg.reactions) msg.reactions = {};

            if(msg.reactions[myUid] && msg.reactions[myUid].emoji === emoji) {
                 delete msg.reactions[myUid];
            } else if (emoji !== '') {
                 msg.reactions[myUid] = { emoji: emoji, timestamp: Date.now() };
            }
            
            messagesMap.set(id, msg);
            renderAll(); // Refresh UI immediately
        }

        // --- 2. FIREBASE UPDATE ---
        const msgRef = db.collection("chats").doc(chatId).collection("messages").doc(id);
        const doc = await msgRef.get();
        const data = doc.data();
        let currentReaction = (data.reactions && data.reactions[myUid]) ? data.reactions[myUid].emoji : null;

        if (currentReaction === emoji) {
            await msgRef.update({ [`reactions.${myUid}`]: firebase.firestore.FieldValue.delete() });
        } else {
            await msgRef.update({ [`reactions.${myUid}`]: { emoji: emoji, timestamp: Date.now() } });
        }
    }

    function showReactionDetails(msgId, event) {
        event.stopPropagation();
        const msgData = messagesMap.get(msgId);
        if (!msgData || !msgData.reactions) return;

        const listContainer = document.getElementById('react-list-items');
        listContainer.innerHTML = '';

        Object.entries(msgData.reactions).forEach(([uid, rData]) => {
            const isMe = uid === myUid;
            // FIX: Use stored myUserData for my PFP
            const pfpSrc = isMe ? (myUserData ? myUserData.photoURL : 'https://via.placeholder.com/40') : chatTargetData.photoURL;
            const name = isMe ? "You" : (chatTargetData.name || chatTargetData.username);
            const timeStr = formatTime12(new Date(rData.timestamp));

            const el = document.createElement('div');
            el.className = 'reactor-item';
            el.innerHTML = `
                <img src="${pfpSrc}" class="reactor-pfp">
                <div class="reactor-info">
                    <div class="reactor-name">${name}</div>
                    <div class="reactor-time">${timeStr}</div>
                </div>
                <div class="reactor-emoji">${rData.emoji}</div>
            `;
            listContainer.appendChild(el);
        });
        document.getElementById('reaction-details-overlay').style.display = 'flex';
    }

    function closeReactionDetails() { document.getElementById('reaction-details-overlay').style.display = 'none'; }
    
    // Note: The Grid function 'expandEmojiMenu' was removed here to prevent conflict
    // and ensure usage of the Full Component modal defined above.

    function initReplyFromActive() {
        triggerReply(document.getElementById('text-'+activeMenuId).innerText.split('(edited)')[0].trim());
        closeMenu();
    }

    function closeMenu() { document.getElementById('menu-overlay').style.display = 'none'; }
    
    // Unified Cancel function for Replying AND Editing
    // FIX: Properly clears edit mode ID to prevent overwriting
    function cancelInteraction() { 
        // FIX: Clear input ONLY if we were editing. If replying, keep draft.
        if (editModeId) {
            mInput.value = "";
            mInput.style.height = 'auto';
        }
        
        replyingTo = null; 
        editModeId = null;
        document.getElementById('reply-dock').style.display = 'none'; 
        // REMOVED mInput.blur() to keep keyboard open
    }
    
    // NEW: Proper Edit Mode with UI Feedback
    function initEdit() {
        const textToEdit = document.getElementById('text-'+activeMenuId).innerText.split('(edited)')[0].trim();
        mInput.value = textToEdit;
        mInput.style.height = 'auto'; 
        mInput.style.height = mInput.scrollHeight + 'px';
        
        editModeId = activeMenuId; 
        closeMenu(); 
        
        // Show the dock as "Editing"
        document.getElementById('reply-text').innerHTML = "<strong style='color:#0095f6'>Editing Message:</strong><br> " + textToEdit;
        document.getElementById('reply-dock').style.display = 'flex';
        
        mInput.focus();
    }

    async function unsendMsg() { 
        const idToDelete = activeMenuId; closeMenu();
        // Optimistic Remove
        if (messagesMap.has(idToDelete)) { messagesMap.delete(idToDelete); renderAll(); }
        
        await db.collection("chats").doc(chatId).collection("messages").doc(idToDelete).delete();
        const snapshot = await db.collection("chats").doc(chatId).collection("messages").orderBy("timestamp", "desc").limit(1).get();
        if (!snapshot.empty) {
            const lastMsg = snapshot.docs[0].data();
            await db.collection("chats").doc(chatId).update({ lastMessage: lastMsg.text, lastSender: lastMsg.sender, lastTimestamp: lastMsg.timestamp });
        }
    }
</script>

<script src="components/call-notifier.js" defer></script>
<call-notifier></call-notifier>

</body>
</html>
